.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PARALLEL 1"
.TH PARALLEL 1 "2023-07-23" "20230722" "parallel"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
parallel \- build and execute shell command lines from standard input
in parallel
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBparallel\fR [options] [\fIcommand\fR [arguments]] < list_of_arguments
.PP
\&\fBparallel\fR [options] [\fIcommand\fR [arguments]] ( \fB:::\fR arguments |
\&\fB:::+\fR arguments | \fB::::\fR argfile(s) | \fB::::+\fR argfile(s) ) ...
.PP
\&\fBparallel\fR \-\-semaphore [options] \fIcommand\fR
.PP
\&\fB#!/usr/bin/parallel\fR \-\-shebang [options] [\fIcommand\fR [arguments]]
.PP
\&\fB#!/usr/bin/parallel\fR \-\-shebang\-wrap [options] [\fIcommand\fR
[arguments]]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1STOP\s0!
.PP
Read the \fBReader's guide\fR below if you are new to \s-1GNU\s0 \fBparallel\fR.
.PP
\&\s-1GNU\s0 \fBparallel\fR is a shell tool for executing jobs in parallel using
one or more computers. A job can be a single command or a small script
that has to be run for each of the lines in the input. The typical
input is a list of files, a list of hosts, a list of users, a list of
URLs, or a list of tables. A job can also be a command that reads from
a pipe. \s-1GNU\s0 \fBparallel\fR can then split the input into blocks and pipe
a block into each command in parallel.
.PP
If you use xargs and tee today you will find \s-1GNU\s0 \fBparallel\fR very easy
to use as \s-1GNU\s0 \fBparallel\fR is written to have the same options as
xargs. If you write loops in shell, you will find \s-1GNU\s0 \fBparallel\fR may
be able to replace most of the loops and make them run faster by
running several jobs in parallel.
.PP
\&\s-1GNU\s0 \fBparallel\fR makes sure output from the commands is the same output
as you would get had you run the commands sequentially. This makes it
possible to use output from \s-1GNU\s0 \fBparallel\fR as input for other
programs.
.PP
For each line of input \s-1GNU\s0 \fBparallel\fR will execute \fIcommand\fR with
the line as arguments. If no \fIcommand\fR is given, the line of input is
executed. Several lines will be run in parallel. \s-1GNU\s0 \fBparallel\fR can
often be used as a substitute for \fBxargs\fR or \fBcat | bash\fR.
.SS "Reader's guide"
.IX Subsection "Reader's guide"
\&\s-1GNU\s0 \fBparallel\fR includes the 4 types of documentation: Tutorial,
how-to, reference and explanation/design.
.PP
\fITutorial\fR
.IX Subsection "Tutorial"
.PP
If you prefer reading a book buy \fB\s-1GNU\s0 Parallel 2018\fR at
https://www.lulu.com/shop/ole\-tange/gnu\-parallel\-2018/paperback/product\-23558902.html
or download it at: https://doi.org/10.5281/zenodo.1146014 Read at
least chapter 1+2. It should take you less than 20 minutes.
.PP
Otherwise start by watching the intro videos for a quick introduction:
https://youtube.com/playlist?list=PL284C9FF2488BC6D1
.PP
If you want to dive deeper: spend a couple of hours walking through
the tutorial (\fBman parallel_tutorial\fR). Your command line will love
you for it.
.PP
\fIHow-to\fR
.IX Subsection "How-to"
.PP
You can find a lot of examples of use in \fBman
parallel_examples\fR. They will give you an idea of what \s-1GNU\s0 \fBparallel\fR
is capable of, and you may find a solution you can simply adapt to
your situation.
.PP
If the example do not cover your exact needs, the options map
(https://www.gnu.org/software/parallel/parallel_options_map.pdf) can
help you identify options that are related, so you can look these up
in the man page.
.PP
\fIReference\fR
.IX Subsection "Reference"
.PP
If you need a one page printable cheat sheet you can find it on:
https://www.gnu.org/software/parallel/parallel_cheat.pdf
.PP
The man page is the reference for all options, and reading the man
page from cover to cover is probably not what you need.
.PP
\fIDesign discussion\fR
.IX Subsection "Design discussion"
.PP
If you want to know the design decisions behind \s-1GNU\s0 \fBparallel\fR, try:
\&\fBman parallel_design\fR. This is also a good intro if you intend to
change \s-1GNU\s0 \fBparallel\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fIcommand\fR" 4
.IX Item "command"
Command to execute.
.Sp
If \fIcommand\fR or the following arguments contain
replacement strings (such as \fB{}\fR) every instance will be substituted
with the input.
.Sp
If \fIcommand\fR is given, \s-1GNU\s0 \fBparallel\fR solve the same tasks as
\&\fBxargs\fR. If \fIcommand\fR is not given \s-1GNU\s0 \fBparallel\fR will behave
similar to \fBcat | sh\fR.
.Sp
The \fIcommand\fR must be an executable, a script, a composed command, an
alias, or a function.
.Sp
\&\fBBash functions\fR: \fBexport \-f\fR the function first or use \fBenv_parallel\fR.
.Sp
\&\fBBash, Csh, or Tcsh aliases\fR: Use \fBenv_parallel\fR.
.Sp
\&\fBZsh, Fish, Ksh, and Pdksh functions and aliases\fR: Use \fBenv_parallel\fR.
.IP "\fB{}\fR" 4
.IX Item "{}"
Input line.
.Sp
This replacement string will be replaced by a full line read from the
input source. The input source is normally stdin (standard input), but
can also be given with \fB\-\-arg\-file\fR, \fB:::\fR, or \fB::::\fR.
.Sp
The replacement string \fB{}\fR can be changed with \fB\-I\fR.
.Sp
If the command line contains no replacement strings then \fB{}\fR will be
appended to the command line.
.Sp
Replacement strings are normally quoted, so special characters are not
parsed by the shell. The exception is if the command starts with a
replacement string; then the string is not quoted.
.Sp
See also: \fB\-\-plus\fR \fB{.}\fR \fB{/}\fR \fB{//}\fR \fB{/.}\fR \fB{#}\fR \fB{%}\fR
\&\fB{\fR\fIn\fR\fB}\fR \fB{=\fR\fIperl expression\fR\fB=}\fR
.IP "\fB{.}\fR" 4
.IX Item "{.}"
Input line without extension.
.Sp
This replacement string will be replaced by the input with the
extension removed. If the input line contains \fB.\fR after the last
\&\fB/\fR, the last \fB.\fR until the end of the string will be removed and
\&\fB{.}\fR will be replaced with the remaining. E.g. \fIfoo.jpg\fR becomes
\&\fIfoo\fR, \fIsubdir/foo.jpg\fR becomes \fIsubdir/foo\fR,
\&\fIsub.dir/foo.jpg\fR becomes \fIsub.dir/foo\fR, \fIsub.dir/bar\fR remains
\&\fIsub.dir/bar\fR. If the input line does not contain \fB.\fR it will remain
unchanged.
.Sp
The replacement string \fB{.}\fR can be changed with \fB\-\-extensionreplace\fR
.Sp
See also: \fB{}\fR \fB\-\-extensionreplace\fR
.IP "\fB{/}\fR" 4
.IX Item "{/}"
Basename of input line.
.Sp
This replacement string will be replaced by the input with the
directory part removed.
.Sp
See also: \fB{}\fR \fB\-\-basenamereplace\fR
.IP "\fB{//}\fR" 4
.IX Item "{//}"
Dirname of input line.
.Sp
This replacement string will be replaced by the dir of the input
line. See \fBdirname\fR(1).
.Sp
See also: \fB{}\fR \fB\-\-dirnamereplace\fR
.IP "\fB{/.}\fR" 4
.IX Item "{/.}"
Basename of input line without extension.
.Sp
This replacement string will be replaced by the input with the
directory and extension part removed.  \fB{/.}\fR is a combination of
\&\fB{/}\fR and \fB{.}\fR.
.Sp
See also: \fB{}\fR \fB\-\-basenameextensionreplace\fR
.IP "\fB{#}\fR" 4
.IX Item "{#}"
Sequence number of the job to run.
.Sp
This replacement string will be replaced by the sequence number of the
job being run. It contains the same number as \f(CW$PARALLEL_SEQ\fR.
.Sp
See also: \fB{}\fR \fB\-\-seqreplace\fR
.IP "\fB{%}\fR" 4
.IX Item "{%}"
Job slot number.
.Sp
This replacement string will be replaced by the job's slot number
between 1 and number of jobs to run in parallel. There will never be 2
jobs running at the same time with the same job slot number.
.Sp
If the job needs to be retried (e.g using \fB\-\-retries\fR or
\&\fB\-\-retry\-failed\fR) the job slot is not automatically updated. You
should then instead use \fB\f(CB$PARALLEL_JOBSLOT\fB\fR:
.Sp
.Vb 10
\&  $ do_test() {
\&      id="$3 {%}=$1 PARALLEL_JOBSLOT=$2"
\&      echo run "$id";
\&      sleep 1
\&      # fail if {%} is odd
\&      return \`echo $1%2 | bc\`
\&    }
\&  $ export \-f do_test
\&  $ parallel \-j3 \-\-jl mylog do_test {%} \e$PARALLEL_JOBSLOT {} ::: A B C D
\&  run A {%}=1 PARALLEL_JOBSLOT=1
\&  run B {%}=2 PARALLEL_JOBSLOT=2
\&  run C {%}=3 PARALLEL_JOBSLOT=3
\&  run D {%}=1 PARALLEL_JOBSLOT=1
\&  $ parallel \-\-retry\-failed \-j3 \-\-jl mylog do_test {%} \e$PARALLEL_JOBSLOT {} ::: A B C D
\&  run A {%}=1 PARALLEL_JOBSLOT=1
\&  run C {%}=3 PARALLEL_JOBSLOT=2
\&  run D {%}=1 PARALLEL_JOBSLOT=3
.Ve
.Sp
Notice how {%} and \f(CW$PARALLEL_JOBSLOT\fR differ in the retry run of C and D.
.Sp
See also: \fB{}\fR \fB\-\-jobs\fR \fB\-\-slotreplace\fR
.IP "\fB{\fR\fIn\fR\fB}\fR" 4
.IX Item "{n}"
Argument from input source \fIn\fR or the \fIn\fR'th argument.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-\-arg\-file\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). If \fIn\fR is negative it refers
to the \fIn\fR'th last argument.
.Sp
See also: \fB{}\fR \fB{\fR\fIn\fR.\fB}\fR \fB{\fR\fIn\fR/\fB}\fR \fB{\fR\fIn\fR//\fB}\fR
\&\fB{\fR\fIn\fR/.\fB}\fR
.IP "\fB{\fR\fIn\fR.\fB}\fR" 4
.IX Item "{n.}"
Argument from input source \fIn\fR or the \fIn\fR'th argument without
extension.
.Sp
\&\fB{\fR\fIn\fR.\fB}\fR is a combination of \fB{\fR\fIn\fR\fB}\fR and \fB{.}\fR.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-\-arg\-file\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). The input will have the
extension removed.
.Sp
See also: \fB{\fR\fIn\fR\fB}\fR \fB{.}\fR
.IP "\fB{\fR\fIn\fR/\fB}\fR" 4
.IX Item "{n/}"
Basename of argument from input source \fIn\fR or the \fIn\fR'th argument.
.Sp
\&\fB{\fR\fIn\fR/\fB}\fR is a combination of \fB{\fR\fIn\fR\fB}\fR and \fB{/}\fR.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-\-arg\-file\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). The input will have the
directory (if any) removed.
.Sp
See also: \fB{\fR\fIn\fR\fB}\fR \fB{/}\fR
.IP "\fB{\fR\fIn\fR//\fB}\fR" 4
.IX Item "{n//}"
Dirname of argument from input source \fIn\fR or the \fIn\fR'th argument.
.Sp
\&\fB{\fR\fIn\fR//\fB}\fR is a combination of \fB{\fR\fIn\fR\fB}\fR and \fB{//}\fR.
.Sp
This positional replacement string will be replaced by the dir of the
input from input source \fIn\fR (when used with \fB\-\-arg\-file\fR or \fB::::\fR) or with
the \fIn\fR'th argument (when used with \fB\-N\fR). See \fBdirname\fR(1).
.Sp
See also: \fB{\fR\fIn\fR\fB}\fR \fB{//}\fR
.IP "\fB{\fR\fIn\fR/.\fB}\fR" 4
.IX Item "{n/.}"
Basename of argument from input source \fIn\fR or the \fIn\fR'th argument
without extension.
.Sp
\&\fB{\fR\fIn\fR/.\fB}\fR is a combination of \fB{\fR\fIn\fR\fB}\fR, \fB{/}\fR, and
\&\fB{.}\fR.
.Sp
This positional replacement string will be replaced by the input from
input source \fIn\fR (when used with \fB\-\-arg\-file\fR or \fB::::\fR) or with the
\&\fIn\fR'th argument (when used with \fB\-N\fR). The input will have the
directory (if any) and extension removed.
.Sp
See also: \fB{\fR\fIn\fR\fB}\fR \fB{/.}\fR
.IP "\fB{=\fR\fIperl expression\fR\fB=}\fR" 4
.IX Item "{=perl expression=}"
Replace with calculated \fIperl expression\fR.
.Sp
\&\fB\f(CB$_\fB\fR will contain the same as \fB{}\fR. After evaluating \fIperl
expression\fR \fB\f(CB$_\fB\fR will be used as the value. It is recommended to only
change \f(CW$_\fR but you have full access to all of \s-1GNU\s0 \fBparallel\fR's
internal functions and data structures.
.Sp
The expression must give the same result if evaluated twice \-
otherwise the behaviour is undefined. E.g. this will not work as expected:
.Sp
.Vb 1
\&    parallel echo \*(Aq{= $_= ++$wrong_counter =}\*(Aq ::: a b c
.Ve
.Sp
A few convenience functions and data structures have been made:
.RS 4
.IP " \fBQ(\fR\fIstring\fR\fB)\fR" 15
.IX Item " Q(string)"
shell quote a string
.IP " \fBpQ(\fR\fIstring\fR\fB)\fR" 15
.IX Item " pQ(string)"
perl quote a string
.IP " \fB\fBuq()\fB\fR (or \fBuq\fR)" 15
.IX Item " uq() (or uq)"
do not quote current replacement string
.IP " \fBhash(val)\fR" 15
.IX Item " hash(val)"
compute B::hash(val)
.IP " \fB\fBtotal_jobs()\fB\fR" 15
.IX Item " total_jobs()"
number of jobs in total
.IP " \fB\fBslot()\fB\fR" 15
.IX Item " slot()"
slot number of job
.IP " \fB\fBseq()\fB\fR" 15
.IX Item " seq()"
sequence number of job
.IP " \fB\f(CB@arg\fB\fR" 15
.IX Item " @arg"
the arguments
.IP " \fB\fBskip()\fB\fR" 15
.IX Item " skip()"
skip this job (see also \fB\-\-filter\fR)
.IP " \fByyyy_mm_dd_hh_mm_ss(sec)\fR (alpha testing)" 15
.IX Item " yyyy_mm_dd_hh_mm_ss(sec) (alpha testing)"
.PD 0
.IP " \fByyyy_mm_dd_hh_mm(sec)\fR (alpha testing)" 15
.IX Item " yyyy_mm_dd_hh_mm(sec) (alpha testing)"
.IP " \fByyyy_mm_dd(sec)\fR (alpha testing)" 15
.IX Item " yyyy_mm_dd(sec) (alpha testing)"
.IP " \fBhh_mm_ss(sec)\fR (alpha testing)" 15
.IX Item " hh_mm_ss(sec) (alpha testing)"
.IP " \fBhh_mm(sec)\fR (alpha testing)" 15
.IX Item " hh_mm(sec) (alpha testing)"
.IP " \fByyyymmddhhmmss(sec)\fR (alpha testing)" 15
.IX Item " yyyymmddhhmmss(sec) (alpha testing)"
.IP " \fByyyymmddhhmm(sec)\fR (alpha testing)" 15
.IX Item " yyyymmddhhmm(sec) (alpha testing)"
.IP " \fByyyymmdd(sec)\fR (alpha testing)" 15
.IX Item " yyyymmdd(sec) (alpha testing)"
.IP " \fBhhmmss(sec)\fR (alpha testing)" 15
.IX Item " hhmmss(sec) (alpha testing)"
.IP " \fBhhmm(sec)\fR (alpha testing)" 15
.IX Item " hhmm(sec) (alpha testing)"
.PD
time functions. \fIsec\fR is number of seconds since epoch. If left out
it will use current local time.
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 3
\&  seq 10 | parallel echo {} + 1 is {= \*(Aq$_++\*(Aq =}
\&  parallel csh \-c {= \*(Aq$_="mkdir ".Q($_)\*(Aq =} ::: \*(Aq12" dir\*(Aq
\&  seq 50 | parallel echo job {#} of {= \*(Aq$_=total_jobs()\*(Aq =}
.Ve
.Sp
See also: \fB\-\-rpl\fR \fB\-\-parens\fR \fB{}\fR \fB{=\fR\fIn\fR \fIperl expression\fR\fB=}\fR
\&\fB\-\-filter\fR
.RE
.IP "\fB{=\fR\fIn\fR \fIperl expression\fR\fB=}\fR" 4
.IX Item "{=n perl expression=}"
Positional equivalent to \fB{=\fR\fIperl expression\fR\fB=}\fR.
.Sp
To understand positional replacement strings see \fB{\fR\fIn\fR\fB}\fR.
.Sp
See also: \fB{=\fR\fIperl expression\fR\fB=}\fR \fB{\fR\fIn\fR\fB}\fR
.IP "\fB:::\fR \fIarguments\fR" 4
.IX Item "::: arguments"
Use arguments on the command line as input source.
.Sp
Unlike other options for \s-1GNU\s0 \fBparallel\fR \fB:::\fR is placed after the
\&\fIcommand\fR and before the arguments.
.Sp
The following are equivalent:
.Sp
.Vb 6
\&  (echo file1; echo file2) | parallel gzip
\&  parallel gzip ::: file1 file2
\&  parallel gzip {} ::: file1 file2
\&  parallel \-\-arg\-sep ,, gzip {} ,, file1 file2
\&  parallel \-\-arg\-sep ,, gzip ,, file1 file2
\&  parallel ::: "gzip file1" "gzip file2"
.Ve
.Sp
To avoid treating \fB:::\fR as special use \fB\-\-arg\-sep\fR to set the
argument separator to something else.
.Sp
If multiple \fB:::\fR are given, each group will be treated as an input
source, and all combinations of input sources will be
generated. E.g. ::: 1 2 ::: a b c will result in the combinations
(1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful for replacing
nested for-loops.
.Sp
\&\fB:::\fR, \fB::::\fR, and \fB\-\-arg\-file\fR can be mixed. So these are equivalent:
.Sp
.Vb 11
\&  parallel echo {1} {2} {3} ::: 6 7 ::: 4 5 ::: 1 2 3
\&  parallel echo {1} {2} {3} :::: <(seq 6 7) <(seq 4 5) \e
\&    :::: <(seq 1 3)
\&  parallel \-a <(seq 6 7) echo {1} {2} {3} :::: <(seq 4 5) \e
\&    :::: <(seq 1 3)
\&  parallel \-a <(seq 6 7) \-a <(seq 4 5) echo {1} {2} {3} \e
\&    ::: 1 2 3
\&  seq 6 7 | parallel \-a \- \-a <(seq 4 5) echo {1} {2} {3} \e
\&    ::: 1 2 3
\&  seq 4 5 | parallel echo {1} {2} {3} :::: <(seq 6 7) \- \e
\&    ::: 1 2 3
.Ve
.Sp
See also: \fB\-\-arg\-sep\fR \fB\-\-arg\-file\fR \fB::::\fR \fB:::+\fR \fB::::+\fR \fB\-\-link\fR
.IP "\fB:::+\fR \fIarguments\fR" 4
.IX Item ":::+ arguments"
Like \fB:::\fR but linked like \fB\-\-link\fR to the previous input source.
.Sp
Contrary to \fB\-\-link\fR, values do not wrap: The shortest input source
determines the length.
.Sp
Example:
.Sp
.Vb 1
\&  parallel echo ::: a b c :::+ 1 2 3 ::: X Y :::+ 11 22
.Ve
.Sp
See also: \fB::::+\fR \fB\-\-link\fR
.IP "\fB::::\fR \fIargfiles\fR" 4
.IX Item ":::: argfiles"
Another way to write \fB\-\-arg\-file\fR \fIargfile1\fR \fB\-\-arg\-file\fR \fIargfile2\fR ...
.Sp
\&\fB:::\fR and \fB::::\fR can be mixed.
.Sp
See also: \fB\-\-arg\-file\fR \fB:::\fR \fB::::+\fR \fB\-\-link\fR
.IP "\fB::::+\fR \fIargfiles\fR" 4
.IX Item "::::+ argfiles"
Like \fB::::\fR but linked like \fB\-\-link\fR to the previous input source.
.Sp
Contrary to \fB\-\-link\fR, values do not wrap: The shortest input source
determines the length.
.Sp
See also: \fB\-\-arg\-file\fR \fB:::+\fR \fB\-\-link\fR
.IP "\fB\-\-null\fR" 4
.IX Item "--null"
.PD 0
.IP "\fB\-0\fR" 4
.IX Item "-0"
.PD
Use \s-1NUL\s0 as delimiter.
.Sp
Normally input lines will end in \en (newline). If they end in \e0
(\s-1NUL\s0), then use this option. It is useful for processing arguments
that may contain \en (newline).
.Sp
Shorthand for \fB\-\-delimiter '\e0'\fR.
.Sp
See also: \fB\-\-delimiter\fR
.IP "\fB\-\-arg\-file\fR \fIinput-file\fR" 4
.IX Item "--arg-file input-file"
.PD 0
.IP "\fB\-a\fR \fIinput-file\fR" 4
.IX Item "-a input-file"
.PD
Use \fIinput-file\fR as input source.
.Sp
If you use this option, stdin (standard input) is given to the first
process run.  Otherwise, stdin (standard input) is redirected from
/dev/null.
.Sp
If multiple \fB\-\-arg\-file\fR are given, each \fIinput-file\fR will be treated as an
input source, and all combinations of input sources will be
generated. E.g. The file \fBfoo\fR contains \fB1 2\fR, the file
\&\fBbar\fR contains \fBa b c\fR.  \fB\-a foo\fR \fB\-a bar\fR will result in the combinations
(1,a) (1,b) (1,c) (2,a) (2,b) (2,c). This is useful for replacing
nested for-loops.
.Sp
See also: \fB\-\-link\fR \fB{\fR\fIn\fR\fB}\fR \fB::::\fR \fB::::+\fR \fB:::\fR
.IP "\fB\-\-arg\-file\-sep\fR \fIsep-str\fR" 4
.IX Item "--arg-file-sep sep-str"
Use \fIsep-str\fR instead of \fB::::\fR as separator string between command
and argument files.
.Sp
Useful if \fB::::\fR is used for something else by the command.
.Sp
See also: \fB::::\fR
.IP "\fB\-\-arg\-sep\fR \fIsep-str\fR" 4
.IX Item "--arg-sep sep-str"
Use \fIsep-str\fR instead of \fB:::\fR as separator string.
.Sp
Useful if \fB:::\fR is used for something else by the command.
.Sp
Also useful if you command uses \fB:::\fR but you still want to read
arguments from stdin (standard input): Simply change \fB\-\-arg\-sep\fR to a
string that is not in the command line.
.Sp
See also: \fB:::\fR
.IP "\fB\-\-bar\fR" 4
.IX Item "--bar"
Show progress as a progress bar.
.Sp
In the bar is shown: % of jobs completed, estimated seconds left, and
number of jobs started.
.Sp
It is compatible with \fBzenity\fR:
.Sp
.Vb 3
\&  seq 1000 | parallel \-j30 \-\-bar \*(Aq(echo {};sleep 0.1)\*(Aq \e
\&    2> >(perl \-pe \*(AqBEGIN{$/="\er";$|=1};s/\er/\en/g\*(Aq |
\&         zenity \-\-progress \-\-auto\-kill) | wc
.Ve
.Sp
See also: \fB\-\-eta\fR \fB\-\-progress\fR \fB\-\-total\-jobs\fR
.IP "\fB\-\-basefile\fR \fIfile\fR" 4
.IX Item "--basefile file"
.PD 0
.IP "\fB\-\-bf\fR \fIfile\fR" 4
.IX Item "--bf file"
.PD
\&\fIfile\fR will be transferred to each sshlogin before first job is
started.
.Sp
It will be removed if \fB\-\-cleanup\fR is active. The file may be a script
to run or some common base data needed for the job.  Multiple
\&\fB\-\-bf\fR can be specified to transfer more basefiles. The \fIfile\fR will be
transferred the same way as \fB\-\-transferfile\fR.
.Sp
See also: \fB\-\-sshlogin\fR \fB\-\-transfer\fR \fB\-\-return\fR \fB\-\-cleanup\fR
\&\fB\-\-workdir\fR
.IP "\fB\-\-basenamereplace\fR \fIreplace-str\fR" 4
.IX Item "--basenamereplace replace-str"
.PD 0
.IP "\fB\-\-bnr\fR \fIreplace-str\fR" 4
.IX Item "--bnr replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{/}\fR for
basename of input line.
.Sp
See also: \fB{/}\fR
.IP "\fB\-\-basenameextensionreplace\fR \fIreplace-str\fR" 4
.IX Item "--basenameextensionreplace replace-str"
.PD 0
.IP "\fB\-\-bner\fR \fIreplace-str\fR" 4
.IX Item "--bner replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{/.}\fR for basename of input line without extension.
.Sp
See also: \fB{/.}\fR
.IP "\fB\-\-bin\fR \fIbinexpr\fR" 4
.IX Item "--bin binexpr"
Use \fIbinexpr\fR as binning key and bin input to the jobs.
.Sp
\&\fIbinexpr\fR is [column number|column name] [perlexpression] e.g.:
.Sp
.Vb 4
\&  3
\&  Address
\&  3 $_%=100
\&  Address s/\eD//g
.Ve
.Sp
Each input line is split using \fB\-\-colsep\fR. The value of the column is
put into \f(CW$_\fR, the perl expression is executed, the resulting value is
is the job slot that will be given the line. If the value is bigger
than the number of jobslots the value will be modulo number of jobslots.
.Sp
This is similar to \fB\-\-shard\fR but the hashing algorithm is a simple
modulo, which makes it predictible which jobslot will receive which
value.
.Sp
The performance is in the order of 100K rows per second. Faster if the
\&\fIbincol\fR is small (<10), slower if it is big (>100).
.Sp
\&\fB\-\-bin\fR requires \fB\-\-pipe\fR and a fixed numeric value for \fB\-\-jobs\fR.
.Sp
See also: \s-1SPREADING BLOCKS OF DATA\s0 \fB\-\-group\-by\fR \fB\-\-round\-robin\fR
\&\fB\-\-shard\fR
.IP "\fB\-\-bg\fR" 4
.IX Item "--bg"
Run command in background.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will normally wait for the completion of a job. With
\&\fB\-\-bg\fR \s-1GNU\s0 \fBparallel\fR will not wait for completion of the command
before exiting.
.Sp
This is the default if \fB\-\-semaphore\fR is set.
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also: \fB\-\-fg\fR \fBman sem\fR
.IP "\fB\-\-bibtex\fR" 4
.IX Item "--bibtex"
.PD 0
.IP "\fB\-\-citation\fR" 4
.IX Item "--citation"
.PD
Print the citation notice and BibTeX entry for \s-1GNU\s0 \fBparallel\fR,
silence citation notice for all future runs, and exit. It will not run
any commands.
.Sp
If it is impossible for you to run \fB\-\-citation\fR you can instead use
\&\fB\-\-will\-cite\fR, which will run commands, but which will only silence
the citation notice for this single run.
.Sp
If you use \fB\-\-will\-cite\fR in scripts to be run by others you are
making it harder for others to see the citation notice.  The
development of \s-1GNU\s0 \fBparallel\fR is indirectly financed through
citations, so if your users do not know they should cite then you are
making it harder to finance development. However, if you pay 10000
\&\s-1EUR,\s0 you have done your part to finance future development and should
feel free to use \fB\-\-will\-cite\fR in scripts.
.Sp
If you do not want to help financing future development by letting
other users see the citation notice or by paying, then please consider
using another tool instead of \s-1GNU\s0 \fBparallel\fR. You can find some of
the alternatives in \fBman parallel_alternatives\fR.
.IP "\fB\-\-block\fR \fIsize\fR" 4
.IX Item "--block size"
.PD 0
.IP "\fB\-\-block\-size\fR \fIsize\fR" 4
.IX Item "--block-size size"
.PD
Size of block in bytes to read at a time.
.Sp
The \fIsize\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p.
.Sp
\&\s-1GNU\s0 \fBparallel\fR tries to meet the block size but can be off by the
length of one record. For performance reasons \fIsize\fR should be bigger
than a two records. \s-1GNU\s0 \fBparallel\fR will warn you and automatically
increase the size if you choose a \fIsize\fR that is too small.
.Sp
If you use \fB\-N\fR, \fB\-\-block\fR should be bigger than N+1 records.
.Sp
\&\fIsize\fR defaults to 1M.
.Sp
When using \fB\-\-pipe\-part\fR a negative block size is not interpreted as a
blocksize but as the number of blocks each jobslot should have. So
this will run 10*5 = 50 jobs in total:
.Sp
.Vb 1
\&  parallel \-\-pipe\-part \-a myfile \-\-block \-10 \-j5 wc
.Ve
.Sp
This is an efficient alternative to \fB\-\-round\-robin\fR because data is
never read by \s-1GNU\s0 \fBparallel\fR, but you can still have very few
jobslots process large amounts of data.
.Sp
See also: \s-1UNIT PREFIX\s0 \fB\-N\fR \fB\-\-pipe\fR \fB\-\-pipe\-part\fR \fB\-\-round\-robin\fR
\&\fB\-\-block\-timeout\fR
.IP "\fB\-\-block\-timeout\fR \fIduration\fR" 4
.IX Item "--block-timeout duration"
.PD 0
.IP "\fB\-\-bt\fR \fIduration\fR" 4
.IX Item "--bt duration"
.PD
Timeout for reading block when using \fB\-\-pipe\fR.
.Sp
If it takes longer than \fIduration\fR to read a full block, use the
partial block read so far.
.Sp
\&\fIduration\fR is in seconds, but can be postfixed with s, m, h, or d.
.Sp
See also: \s-1TIME POSTFIXES\s0 \fB\-\-pipe\fR \fB\-\-block\fR
.IP "\fB\-\-cat\fR" 4
.IX Item "--cat"
Create a temporary file with content.
.Sp
Normally \fB\-\-pipe\fR/\fB\-\-pipe\-part\fR will give data to the program on
stdin (standard input). With \fB\-\-cat\fR \s-1GNU\s0 \fBparallel\fR will create a
temporary file with the name in \fB{}\fR, so you can do: \fBparallel
\&\-\-pipe \-\-cat wc {}\fR.
.Sp
Implies \fB\-\-pipe\fR unless \fB\-\-pipe\-part\fR is used.
.Sp
See also: \fB\-\-pipe\fR \fB\-\-pipe\-part\fR \fB\-\-fifo\fR
.IP "\fB\-\-cleanup\fR" 4
.IX Item "--cleanup"
Remove transferred files.
.Sp
\&\fB\-\-cleanup\fR will remove the transferred files on the remote computer
after processing is done.
.Sp
.Vb 3
\&  find log \-name \*(Aq*gz\*(Aq | parallel \e
\&    \-\-sshlogin server.example.com \-\-transferfile {} \e
\&    \-\-return {.}.bz2 \-\-cleanup "zcat {} | bzip \-9 >{.}.bz2"
.Ve
.Sp
With \fB\-\-transferfile {}\fR the file transferred to the remote computer
will be removed on the remote computer. Directories on the remote
computer containing the file will be removed if they are empty.
.Sp
With \fB\-\-return\fR the file transferred from the remote computer will be
removed on the remote computer. Directories on the remote
computer containing the file will be removed if they are empty.
.Sp
\&\fB\-\-cleanup\fR is ignored when not used with \fB\-\-basefile\fR,
\&\fB\-\-transfer\fR, \fB\-\-transferfile\fR or \fB\-\-return\fR.
.Sp
See also: \fB\-\-basefile\fR \fB\-\-transfer\fR \fB\-\-transferfile\fR \fB\-\-sshlogin\fR
\&\fB\-\-return\fR
.IP "\fB\-\-color\fR" 4
.IX Item "--color"
Colour output.
.Sp
Colour the output. Each job gets its own colour combination
(background+foreground).
.Sp
\&\fB\-\-color\fR is ignored when using \fB\-u\fR.
.Sp
See also: \fB\-\-color\-failed\fR
.IP "\fB\-\-color\-failed\fR" 4
.IX Item "--color-failed"
.PD 0
.IP "\fB\-\-cf\fR" 4
.IX Item "--cf"
.PD
Colour the output from failing jobs white on red.
.Sp
Useful if you have a lot of jobs and want to focus on the failing
jobs.
.Sp
\&\fB\-\-color\-failed\fR is ignored when using \fB\-u\fR, \fB\-\-line\-buffer\fR and
unreliable when using \fB\-\-latest\-line\fR.
.Sp
See also: \fB\-\-color\fR
.IP "\fB\-\-colsep\fR \fIregexp\fR" 4
.IX Item "--colsep regexp"
.PD 0
.IP "\fB\-C\fR \fIregexp\fR" 4
.IX Item "-C regexp"
.PD
Column separator.
.Sp
The input will be treated as a table with \fIregexp\fR separating the
columns. The n'th column can be accessed using \fB{\fR\fIn\fR\fB}\fR or
\&\fB{\fR\fIn\fR.\fB}\fR. E.g. \fB{3}\fR is the 3rd column.
.Sp
If there are more input sources, each input source will be separated,
but the columns from each input source will be linked.
.Sp
.Vb 2
\&  parallel \-\-colsep \*(Aq\-\*(Aq echo {4} {3} {2} {1} \e
\&    ::: A\-B C\-D ::: e\-f g\-h
.Ve
.Sp
\&\fB\-\-colsep\fR implies \fB\-\-trim rl\fR, which can be overridden with
\&\fB\-\-trim n\fR.
.Sp
\&\fIregexp\fR is a Perl Regular Expression:
https://perldoc.perl.org/perlre.html
.Sp
See also: \fB\-\-csv\fR \fB{\fR\fIn\fR\fB}\fR \fB\-\-trim\fR \fB\-\-link\fR
.IP "\fB\-\-compress\fR" 4
.IX Item "--compress"
Compress temporary files.
.Sp
If the output is big and very compressible this will take up less disk
space in \f(CW$TMPDIR\fR and possibly be faster due to less disk I/O.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will try \fBpzstd\fR, \fBlbzip2\fR, \fBpbzip2\fR, \fBzstd\fR,
\&\fBpigz\fR, \fBlz4\fR, \fBlzop\fR, \fBplzip\fR, \fBlzip\fR, \fBlrz\fR, \fBgzip\fR, \fBpxz\fR,
\&\fBlzma\fR, \fBbzip2\fR, \fBxz\fR, \fBclzip\fR, in that order, and use the first
available.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will use up to 8 processes per job waiting to be
printed. See \fBman parallel_design\fR for details.
.Sp
See also: \fB\-\-compress\-program\fR
.IP "\fB\-\-compress\-program\fR \fIprg\fR" 4
.IX Item "--compress-program prg"
.PD 0
.IP "\fB\-\-decompress\-program\fR \fIprg\fR" 4
.IX Item "--decompress-program prg"
.PD
Use \fIprg\fR for (de)compressing temporary files.
.Sp
It is assumed that \fIprg \-dc\fR will decompress stdin (standard input)
to stdout (standard output) unless \fB\-\-decompress\-program\fR is given.
.Sp
See also: \fB\-\-compress\fR
.IP "\fB\-\-csv\fR" 4
.IX Item "--csv"
Treat input as CSV-format.
.Sp
\&\fB\-\-colsep\fR sets the field delimiter. It works very much like
\&\fB\-\-colsep\fR except it deals correctly with quoting. Compare:
.Sp
.Vb 2
\&   echo \*(Aq"1 big, 2 small","2""x4"" plank",12.34\*(Aq |
\&     parallel \-\-csv echo {1} of {2} at {3}
\&
\&   echo \*(Aq"1 big, 2 small","2""x4"" plank",12.34\*(Aq |
\&     parallel \-\-colsep \*(Aq,\*(Aq echo {1} of {2} at {3}
.Ve
.Sp
Even quoted newlines are parsed correctly:
.Sp
.Vb 3
\&   (echo \*(Aq"Start of field 1 with newline\*(Aq
\&    echo \*(AqLine 2 in field 1";value 2\*(Aq) |
\&     parallel \-\-csv \-\-colsep \*(Aq;\*(Aq echo Field 1: {1} Field 2: {2}
.Ve
.Sp
When used with \fB\-\-pipe\fR only pass full CSV-records.
.Sp
See also: \fB\-\-pipe\fR \fB\-\-link\fR \fB{\fR\fIn\fR\fB}\fR \fB\-\-colsep\fR \fB\-\-header\fR
.IP "\fB\-\-ctag\fR (obsolete: use \fB\-\-color\fR \fB\-\-tag\fR)" 4
.IX Item "--ctag (obsolete: use --color --tag)"
Color tag.
.Sp
If the values look very similar looking at the output it can be hard
to tell when a new value is used. \fB\-\-ctag\fR gives each value a random
color.
.Sp
See also: \fB\-\-color\fR \fB\-\-tag\fR
.IP "\fB\-\-ctagstring\fR \fIstr\fR (obsolete: use \fB\-\-color\fR \fB\-\-tagstring\fR)" 4
.IX Item "--ctagstring str (obsolete: use --color --tagstring)"
Color tagstring.
.Sp
See also: \fB\-\-color\fR \fB\-\-ctag\fR \fB\-\-tagstring\fR
.IP "\fB\-\-delay\fR \fIduration\fR" 4
.IX Item "--delay duration"
Delay starting next job by \fIduration\fR.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will not start another job for the next \fIduration\fR.
.Sp
\&\fIduration\fR is in seconds, but can be postfixed with s, m, h, or d.
.Sp
If you append 'auto' to \fIduration\fR (e.g. 13m3sauto) \s-1GNU\s0 \fBparallel\fR
will automatically try to find the optimal value: If a job fails,
\&\fIduration\fR is increased by 30%. If a job succeeds, \fIduration\fR is
decreased by 10%.
.Sp
See also: \s-1TIME POSTFIXES\s0 \fB\-\-retries\fR \fB\-\-ssh\-delay\fR
.IP "\fB\-\-delimiter\fR \fIdelim\fR" 4
.IX Item "--delimiter delim"
.PD 0
.IP "\fB\-d\fR \fIdelim\fR" 4
.IX Item "-d delim"
.PD
Input items are terminated by \fIdelim\fR.
.Sp
The specified delimiter may be characters, C\-style character escapes
such as \en, or octal or hexadecimal escape codes.  Octal and
hexadecimal escape codes are understood as for the printf command.
.Sp
See also: \fB\-\-colsep\fR
.IP "\fB\-\-dirnamereplace\fR \fIreplace-str\fR" 4
.IX Item "--dirnamereplace replace-str"
.PD 0
.IP "\fB\-\-dnr\fR \fIreplace-str\fR" 4
.IX Item "--dnr replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{//}\fR for
dirname of input line.
.Sp
See also: \fB{//}\fR
.IP "\fB\-\-dry\-run\fR" 4
.IX Item "--dry-run"
Print the job to run on stdout (standard output), but do not run the
job.
.Sp
Use \fB\-v \-v\fR to include the wrapping that \s-1GNU\s0 \fBparallel\fR generates
(for remote jobs, \fB\-\-tmux\fR, \fB\-\-nice\fR, \fB\-\-pipe\fR, \fB\-\-pipe\-part\fR,
\&\fB\-\-fifo\fR and \fB\-\-cat\fR). Do not count on this literally, though, as
the job may be scheduled on another computer or the local computer if
: is in the list.
.Sp
See also: \fB\-v\fR
.IP "\fB\-E\fR \fIeof-str\fR" 4
.IX Item "-E eof-str"
Set the end of file string to \fIeof-str\fR.
.Sp
If the end of file string occurs as a line of input, the rest of the
input is not read.  If neither \fB\-E\fR nor \fB\-e\fR is used, no end of file
string is used.
.IP "\fB\-\-eof\fR[=\fIeof-str\fR]" 4
.IX Item "--eof[=eof-str]"
.PD 0
.IP "\fB\-e\fR[\fIeof-str\fR]" 4
.IX Item "-e[eof-str]"
.PD
This option is a synonym for the \fB\-E\fR option.
.Sp
Use \fB\-E\fR instead, because it is \s-1POSIX\s0 compliant for \fBxargs\fR while
this option is not.  If \fIeof-str\fR is omitted, there is no end of file
string.  If neither \fB\-E\fR nor \fB\-e\fR is used, no end of file string is
used.
.IP "\fB\-\-embed\fR" 4
.IX Item "--embed"
Embed \s-1GNU\s0 \fBparallel\fR in a shell script.
.Sp
If you need to distribute your script to someone who does not want to
install \s-1GNU\s0 \fBparallel\fR you can embed \s-1GNU\s0 \fBparallel\fR in your own
shell script:
.Sp
.Vb 1
\&  parallel \-\-embed > new_script
.Ve
.Sp
After which you add your code at the end of \fBnew_script\fR. This is tested
on \fBash\fR, \fBbash\fR, \fBdash\fR, \fBksh\fR, \fBsh\fR, and \fBzsh\fR.
.IP "\fB\-\-env\fR \fIvar\fR" 4
.IX Item "--env var"
Copy exported environment variable \fIvar\fR.
.Sp
This will copy \fIvar\fR to the environment that the command is run
in. This is especially useful for remote execution.
.Sp
In Bash \fIvar\fR can also be a Bash function \- just remember to \fBexport
\&\-f\fR the function.
.Sp
The variable '_' is special. It will copy all exported environment
variables except for the ones mentioned in ~/.parallel/ignored_vars.
.Sp
To copy the full environment (both exported and not exported
variables, arrays, and functions) use \fBenv_parallel\fR.
.Sp
See also: \fB\-\-record\-env\fR \fB\-\-session\fR \fB\-\-sshlogin\fR \fIcommand\fR
\&\fBenv_parallel\fR
.IP "\fB\-\-eta\fR" 4
.IX Item "--eta"
Show the estimated number of seconds before finishing.
.Sp
This forces \s-1GNU\s0 \fBparallel\fR to read all jobs before starting to find
the number of jobs (unless you use \fB\-\-total\-jobs\fR). \s-1GNU\s0 \fBparallel\fR
normally only reads the next job to run.
.Sp
The estimate is based on the runtime of finished jobs, so the first
estimate will only be shown when the first job has finished.
.Sp
Implies \fB\-\-progress\fR.
.Sp
See also: \fB\-\-bar\fR \fB\-\-progress\fR \fB\-\-total\-jobs\fR
.IP "\fB\-\-fg\fR" 4
.IX Item "--fg"
Run command in foreground.
.Sp
With \fB\-\-tmux\fR and \fB\-\-tmuxpane\fR \s-1GNU\s0 \fBparallel\fR will start \fBtmux\fR in
the foreground.
.Sp
With \fB\-\-semaphore\fR \s-1GNU\s0 \fBparallel\fR will run the command in the
foreground (opposite \fB\-\-bg\fR), and wait for completion of the command
before exiting. Exit code will be that of the command.
.Sp
See also: \fB\-\-bg\fR \fBman sem\fR
.IP "\fB\-\-fifo\fR" 4
.IX Item "--fifo"
Create a temporary fifo with content.
.Sp
Normally \fB\-\-pipe\fR and \fB\-\-pipe\-part\fR will give data to the program on
stdin (standard input). With \fB\-\-fifo\fR \s-1GNU\s0 \fBparallel\fR will create a
temporary fifo with the name in \fB{}\fR, so you can do:
.Sp
.Vb 1
\&  parallel \-\-pipe \-\-fifo wc {}
.Ve
.Sp
Beware: If the fifo is never opened for reading, the job will block forever:
.Sp
.Vb 2
\&  seq 1000000 | parallel \-\-fifo echo This will block forever
\&  seq 1000000 | parallel \-\-fifo \*(Aqecho This will not block < {}\*(Aq
.Ve
.Sp
By using \fB\-\-fifo\fR instead of \fB\-\-cat\fR you may save I/O as \fB\-\-cat\fR
will write to a temporary file, whereas \fB\-\-fifo\fR will not.
.Sp
Implies \fB\-\-pipe\fR unless \fB\-\-pipe\-part\fR is used.
.Sp
See also: \fB\-\-cat\fR \fB\-\-pipe\fR \fB\-\-pipe\-part\fR
.IP "\fB\-\-filter\fR \fIfilter\fR" 4
.IX Item "--filter filter"
Only run jobs where \fIfilter\fR is true.
.Sp
\&\fIfilter\fR can contain replacement strings and Perl code. Example:
.Sp
.Vb 2
\&  parallel \-\-filter \*(Aq{1}+{2}+{3} < 10\*(Aq echo {1},{2},{3} \e
\&    ::: {1..10} ::: {3..8} ::: {3..10}
.Ve
.Sp
Outputs: 1,3,3 1,3,4 1,3,5 1,4,3 1,4,4 1,5,3 2,3,3 2,3,4 2,4,3 3,3,3
.Sp
.Vb 2
\&  parallel \-\-filter \*(Aq{1} < {2}*{2}\*(Aq echo {1},{2} \e
\&    ::: {1..10} ::: {1..3}
.Ve
.Sp
Outputs: 1,2 1,3 2,2 2,3 3,2 3,3 4,3 5,3 6,3 7,3 8,3
.Sp
.Vb 2
\&  parallel \-\-filter \*(Aq{choose_k}\*(Aq \-\-plus echo {1},{2},{3} \e
\&    ::: {1..5} ::: {1..5} ::: {1..5}
.Ve
.Sp
Outputs: 1,2,3 1,2,4 1,2,5 1,3,4 1,3,5 1,4,5 2,3,4 2,3,5 2,4,5 3,4,5
.Sp
See also: \fB\fBskip()\fB\fR \fB\-\-no\-run\-if\-empty\fR \fB{choose_k}\fR
.IP "\fB\-\-filter\-hosts\fR" 4
.IX Item "--filter-hosts"
Remove down hosts.
.Sp
For each remote host: check that login through ssh works. If not: do
not use this host.
.Sp
For performance reasons, this check is performed only at the start and
every time \fB\-\-sshloginfile\fR is changed. If an host goes down after
the first check, it will go undetected until \fB\-\-sshloginfile\fR is
changed; \fB\-\-retries\fR can be used to mitigate this.
.Sp
Currently you can \fInot\fR put \fB\-\-filter\-hosts\fR in a profile,
\&\f(CW$PARALLEL\fR, /etc/parallel/config or similar. This is because \s-1GNU\s0
\&\fBparallel\fR uses \s-1GNU\s0 \fBparallel\fR to compute this, so you will get an
infinite loop. This will likely be fixed in a later release.
.Sp
See also: \fB\-\-sshloginfile\fR \fB\-\-sshlogin\fR \fB\-\-retries\fR
.IP "\fB\-\-gnu\fR" 4
.IX Item "--gnu"
Behave like \s-1GNU\s0 \fBparallel\fR.
.Sp
This option historically took precedence over \fB\-\-tollef\fR. The
\&\fB\-\-tollef\fR option is now retired, and therefore may not be
used. \fB\-\-gnu\fR is kept for compatibility, but does nothing.
.IP "\fB\-\-group\fR" 4
.IX Item "--group"
Group output.
.Sp
Output from each job is grouped together and is only printed when the
command is finished. Stdout (standard output) first followed by stderr
(standard error).
.Sp
This takes in the order of 0.5ms \s-1CPU\s0 time per job and depends on the
speed of your disk for larger output.
.Sp
\&\fB\-\-group\fR is the default.
.Sp
See also: \fB\-\-line\-buffer\fR \fB\-\-ungroup\fR \fB\-\-tag\fR
.IP "\fB\-\-group\-by\fR \fIval\fR" 4
.IX Item "--group-by val"
Group input by value.
.Sp
Combined with \fB\-\-pipe\fR/\fB\-\-pipe\-part\fR \fB\-\-group\-by\fR groups lines with
the same value into a record.
.Sp
The value can be computed from the full line or from a single column.
.Sp
\&\fIval\fR can be:
.RS 4
.IP " column number" 15
.IX Item " column number"
Use the value in the column numbered.
.IP " column name" 15
.IX Item " column name"
Treat the first line as a header and use the value in the column
named.
.Sp
(Not supported with \fB\-\-pipe\-part\fR).
.IP " perl expression" 15
.IX Item " perl expression"
Run the perl expression and use \f(CW$_\fR as the value.
.IP " column number perl expression" 15
.IX Item " column number perl expression"
Put the value of the column put in \f(CW$_\fR, run the perl expression, and use \f(CW$_\fR as the value.
.IP " column name perl expression" 15
.IX Item " column name perl expression"
Put the value of the column put in \f(CW$_\fR, run the perl expression, and use \f(CW$_\fR as the value.
.Sp
(Not supported with \fB\-\-pipe\-part\fR).
.RE
.RS 4
.Sp
Example:
.Sp
.Vb 7
\&  UserID, Consumption
\&  123,    1
\&  123,    2
\&  12\-3,   1
\&  221,    3
\&  221,    1
\&  2/21,   5
.Ve
.Sp
If you want to group 123, 12\-3, 221, and 2/21 into 4 records and pass
one record at a time to \fBwc\fR:
.Sp
.Vb 2
\&  tail \-n +2 table.csv | \e
\&    parallel \-\-pipe \-\-colsep , \-\-group\-by 1 \-kN1 wc
.Ve
.Sp
Make \s-1GNU\s0 \fBparallel\fR treat the first line as a header:
.Sp
.Vb 2
\&  cat table.csv | \e
\&    parallel \-\-pipe \-\-colsep , \-\-header : \-\-group\-by 1 \-kN1 wc
.Ve
.Sp
Address column by column name:
.Sp
.Vb 2
\&  cat table.csv | \e
\&    parallel \-\-pipe \-\-colsep , \-\-header : \-\-group\-by UserID \-kN1 wc
.Ve
.Sp
If 12\-3 and 123 are really the same UserID, remove non-digits in
UserID when grouping:
.Sp
.Vb 2
\&  cat table.csv | parallel \-\-pipe \-\-colsep , \-\-header : \e
\&    \-\-group\-by \*(AqUserID s/\eD//g\*(Aq \-kN1 wc
.Ve
.Sp
See also: \s-1SPREADING BLOCKS OF DATA\s0 \fB\-\-pipe\fR \fB\-\-pipe\-part\fR \fB\-\-bin\fR
\&\fB\-\-shard\fR \fB\-\-round\-robin\fR
.RE
.IP "\fB\-\-help\fR" 4
.IX Item "--help"
.PD 0
.IP "\fB\-h\fR" 4
.IX Item "-h"
.PD
Print a summary of the options to \s-1GNU\s0 \fBparallel\fR and exit.
.IP "\fB\-\-halt\-on\-error\fR \fIval\fR" 4
.IX Item "--halt-on-error val"
.PD 0
.IP "\fB\-\-halt\fR \fIval\fR" 4
.IX Item "--halt val"
.PD
When should \s-1GNU\s0 \fBparallel\fR terminate?
.Sp
In some situations it makes no sense to run all jobs. \s-1GNU\s0
\&\fBparallel\fR should simply stop as soon as a condition is met.
.Sp
\&\fIval\fR defaults to \fBnever\fR, which runs all jobs no matter what.
.Sp
\&\fIval\fR can also take on the form of \fIwhen\fR,\fIwhy\fR.
.Sp
\&\fIwhen\fR can be 'now' which means kill all running jobs and halt
immediately, or it can be 'soon' which means wait for all running jobs
to complete, but start no new jobs.
.Sp
\&\fIwhy\fR can be 'fail=X', 'fail=Y%', 'success=X', 'success=Y%',
\&'done=X', or 'done=Y%' where X is the number of jobs that has to fail,
succeed, or be done before halting, and Y is the percentage of jobs
that has to fail, succeed, or be done before halting.
.Sp
Example:
.RS 4
.IP " \-\-halt now,fail=1" 23
.IX Item " --halt now,fail=1"
exit when a job has failed. Kill running jobs.
.IP " \-\-halt soon,fail=3" 23
.IX Item " --halt soon,fail=3"
exit when 3 jobs have failed, but wait for running jobs to complete.
.IP " \-\-halt soon,fail=3%" 23
.IX Item " --halt soon,fail=3%"
exit when 3% of the jobs have failed, but wait for running jobs to complete.
.IP " \-\-halt now,success=1" 23
.IX Item " --halt now,success=1"
exit when a job has succeeded. Kill running jobs.
.IP " \-\-halt soon,success=3" 23
.IX Item " --halt soon,success=3"
exit when 3 jobs have succeeded, but wait for running jobs to complete.
.IP " \-\-halt now,success=3%" 23
.IX Item " --halt now,success=3%"
exit when 3% of the jobs have succeeded. Kill running jobs.
.IP " \-\-halt now,done=1" 23
.IX Item " --halt now,done=1"
exit when a job has finished. Kill running jobs.
.IP " \-\-halt soon,done=3" 23
.IX Item " --halt soon,done=3"
exit when 3 jobs have finished, but wait for running jobs to complete.
.IP " \-\-halt now,done=3%" 23
.IX Item " --halt now,done=3%"
exit when 3% of the jobs have finished. Kill running jobs.
.RE
.RS 4
.Sp
For backwards compatibility these also work:
.IP "0" 12
never
.IP "1" 12
.IX Item "1"
soon,fail=1
.IP "2" 12
.IX Item "2"
now,fail=1
.IP "\-1" 12
.IX Item "-1"
soon,success=1
.IP "\-2" 12
.IX Item "-2"
now,success=1
.IP "1\-99%" 12
.IX Item "1-99%"
soon,fail=1\-99%
.RE
.RS 4
.RE
.IP "\fB\-\-header\fR \fIregexp\fR" 4
.IX Item "--header regexp"
Use regexp as header.
.Sp
For normal usage the matched header (typically the first line:
\&\fB\-\-header '.*\en'\fR) will be split using \fB\-\-colsep\fR (which will
default to '\et') and column names can be used as replacement
variables: \fB{column name}\fR, \fB{column name/}\fR, \fB{column name//}\fR,
\&\fB{column name/.}\fR, \fB{column name.}\fR, \fB{=column name perl expression
=}\fR, ..
.Sp
For \fB\-\-pipe\fR the matched header will be prepended to each output.
.Sp
\&\fB\-\-header :\fR is an alias for \fB\-\-header '.*\en'\fR.
.Sp
If \fIregexp\fR is a number, it is a fixed number of lines.
.Sp
\&\fB\-\-header 0\fR is special: It will make replacement strings for files
given with \fB\-\-arg\-file\fR or \fB::::\fR. It will make \fB{foo/bar}\fR for the
file \fBfoo/bar\fR.
.Sp
See also: \fB\-\-colsep\fR \fB\-\-pipe\fR \fB\-\-pipe\-part\fR \fB\-\-arg\-file\fR
.IP "\fB\-\-hostgroups\fR" 4
.IX Item "--hostgroups"
.PD 0
.IP "\fB\-\-hgrp\fR" 4
.IX Item "--hgrp"
.PD
Enable hostgroups on arguments.
.Sp
If an argument contains '@' the string after '@' will be removed and
treated as a list of hostgroups on which this job is allowed to
run. If there is no \fB\-\-sshlogin\fR with a corresponding group, the job
will run on any hostgroup.
.Sp
Example:
.Sp
.Vb 4
\&  parallel \-\-hostgroups \e
\&    \-\-sshlogin @grp1/myserver1 \-S @grp1+grp2/myserver2 \e
\&    \-\-sshlogin @grp3/myserver3 \e
\&    echo ::: my_grp1_arg@grp1 arg_for_grp2@grp2 third@grp1+grp3
.Ve
.Sp
\&\fBmy_grp1_arg\fR may be run on either \fBmyserver1\fR or \fBmyserver2\fR,
\&\fBthird\fR may be run on either \fBmyserver1\fR or \fBmyserver3\fR,
but \fBarg_for_grp2\fR will only be run on \fBmyserver2\fR.
.Sp
See also: \fB\-\-sshlogin\fR \fB\f(CB$PARALLEL_HOSTGROUPS\fB\fR \fB\f(CB$PARALLEL_ARGHOSTGROUPS\fB\fR
.IP "\fB\-I\fR \fIreplace-str\fR" 4
.IX Item "-I replace-str"
Use the replacement string \fIreplace-str\fR instead of \fB{}\fR.
.Sp
See also: \fB{}\fR
.IP "\fB\-\-replace\fR [\fIreplace-str\fR]" 4
.IX Item "--replace [replace-str]"
.PD 0
.IP "\fB\-i\fR [\fIreplace-str\fR]" 4
.IX Item "-i [replace-str]"
.PD
This option is deprecated; use \fB\-I\fR instead.
.Sp
This option is a synonym for \fB\-I\fR\fIreplace-str\fR if \fIreplace-str\fR is
specified, and for \fB\-I {}\fR otherwise.
.Sp
See also: \fB{}\fR
.IP "\fB\-\-joblog\fR \fIlogfile\fR" 4
.IX Item "--joblog logfile"
.PD 0
.IP "\fB\-\-jl\fR \fIlogfile\fR" 4
.IX Item "--jl logfile"
.PD
Logfile for executed jobs.
.Sp
Save a list of the executed jobs to \fIlogfile\fR in the following \s-1TAB\s0
separated format: sequence number, sshlogin, start time as seconds
since epoch, run time in seconds, bytes in files transferred, bytes in
files returned, exit status, signal, and command run.
.Sp
For \fB\-\-pipe\fR bytes transferred and bytes returned are number of input
and output of bytes.
.Sp
If \fBlogfile\fR is prepended with '+' log lines will be appended to the
logfile.
.Sp
To convert the times into \s-1ISO\-8601\s0 strict do:
.Sp
.Vb 2
\&  cat logfile | perl \-a \-F"\et" \-ne \e
\&    \*(Aqchomp($F[2]=\`date \-d \e@$F[2] +%FT%T\`); print join("\et",@F)\*(Aq
.Ve
.Sp
If the host is long, you can use \fBcolumn \-t\fR to pretty print it:
.Sp
.Vb 1
\&  cat joblog | column \-t
.Ve
.Sp
See also: \fB\-\-resume\fR \fB\-\-resume\-failed\fR
.IP "\fB\-\-jobs\fR \fInum\fR" 4
.IX Item "--jobs num"
.PD 0
.IP "\fB\-j\fR \fInum\fR" 4
.IX Item "-j num"
.IP "\fB\-\-max\-procs\fR \fInum\fR" 4
.IX Item "--max-procs num"
.IP "\fB\-P\fR \fInum\fR" 4
.IX Item "-P num"
.PD
Number of jobslots on each machine.
.Sp
Run up to \fInum\fR jobs in parallel. Default is 100%.
.RS 4
.IP "\fInum\fR" 7
.IX Item "num"
Run up to \fInum\fR jobs in parallel.
.IP "0" 7
Run as many as possible (this can take a while to determine).
.Sp
Due to a bug \fB\-j 0\fR will also evaluate replacement strings twice up
to the number of joblots:
.Sp
.Vb 4
\&  # This will not count from 1 but from number\-of\-jobslots
\&  seq 10000 | parallel \-j0   echo \*(Aq{= $_ = $foo++; =}\*(Aq | head
\&  # This will count from 1
\&  seq 10000 | parallel \-j100 echo \*(Aq{= $_ = $foo++; =}\*(Aq | head
.Ve
.IP "\fInum\fR%" 7
.IX Item "num%"
Multiply the number of \s-1CPU\s0 threads by \fInum\fR percent. E.g. 100% means
one job per \s-1CPU\s0 thread on each machine.
.IP "+\fInum\fR" 7
.IX Item "+num"
Add \fInum\fR to the number of \s-1CPU\s0 threads.
.IP "\-\fInum\fR" 7
.IX Item "-num"
Subtract \fInum\fR from the number of \s-1CPU\s0 threads.
.IP "\fIexpr\fR" 7
.IX Item "expr"
Evaluate \fIexpr\fR. E.g. '12/2' to get 6, '+25%' gives the same as
\&'125%', or complex expressions like '+3*log(55)%' which means:
multiply 3 by log(55), multiply that by the number of \s-1CPU\s0 threads and
divide by 100, add this to the number of \s-1CPU\s0 threads.
.IP "\fIprocfile\fR" 7
.IX Item "procfile"
Read parameter from file.
.Sp
Use the content of \fIprocfile\fR as parameter for
\&\fI\-j\fR. E.g. \fIprocfile\fR could contain the string 100% or +2 or 10.
.Sp
If \fIprocfile\fR is changed when a job completes, \fIprocfile\fR is read
again and the new number of jobs is computed. If the number is lower
than before, running jobs will be allowed to finish but new jobs will
not be started until the wanted number of jobs has been reached.  This
makes it possible to change the number of simultaneous running jobs
while \s-1GNU\s0 \fBparallel\fR is running.
.RE
.RS 4
.Sp
If the evaluated number is less than 1 then 1 will be used.
.Sp
If \fB\-\-semaphore\fR is set, the default is 1 thus making a mutex.
.Sp
See also: \fB\-\-use\-cores\-instead\-of\-threads\fR
\&\fB\-\-use\-sockets\-instead\-of\-threads\fR
.RE
.IP "\fB\-\-keep\-order\fR" 4
.IX Item "--keep-order"
.PD 0
.IP "\fB\-k\fR" 4
.IX Item "-k"
.PD
Keep sequence of output same as the order of input.
.Sp
Normally the output of a job will be printed as soon as the job
completes. Try this to see the difference:
.Sp
.Vb 2
\&  parallel \-j4 sleep {}\e; echo {} ::: 2 1 4 3
\&  parallel \-j4 \-k sleep {}\e; echo {} ::: 2 1 4 3
.Ve
.Sp
If used with \fB\-\-onall\fR or \fB\-\-nonall\fR the output will grouped by
sshlogin in sorted order.
.Sp
\&\fB\-\-keep\-order\fR cannot keep the output order when used with \fB\-\-pipe
\&\-\-round\-robin\fR. Here it instead means, that the jobslots will get the
same blocks as input in the same order in every run if the input is
kept the same. Run each of these twice and compare:
.Sp
.Vb 2
\&  seq 10000000 | parallel \-\-pipe \-\-round\-robin \*(Aqsleep 0.$RANDOM; wc\*(Aq
\&  seq 10000000 | parallel \-\-pipe \-k \-\-round\-robin \*(Aqsleep 0.$RANDOM; wc\*(Aq
.Ve
.Sp
\&\fB\-k\fR only affects the order in which the output is printed \- not the
order in which jobs are run.
.Sp
See also: \fB\-\-group\fR \fB\-\-line\-buffer\fR
.IP "\fB\-L\fR \fIrecsize\fR" 4
.IX Item "-L recsize"
When used with \fB\-\-pipe\fR: Read records of \fIrecsize\fR.
.Sp
When used otherwise: Use at most \fIrecsize\fR nonblank input lines per
command line.  Trailing blanks cause an input line to be logically
continued on the next input line.
.Sp
\&\fB\-L 0\fR means read one line, but insert 0 arguments on the command
line.
.Sp
\&\fIrecsize\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR, \fB\-\-xargs\fR, or \fB\-\-pipe\fR is set.
.Sp
See also: \s-1UNIT PREFIX\s0 \fB\-N\fR \fB\-\-max\-lines\fR \fB\-\-block\fR \fB\-X\fR \fB\-m\fR
\&\fB\-\-xargs\fR \fB\-\-pipe\fR
.IP "\fB\-\-max\-lines\fR [\fIrecsize\fR]" 4
.IX Item "--max-lines [recsize]"
.PD 0
.IP "\fB\-l\fR[\fIrecsize\fR]" 4
.IX Item "-l[recsize]"
.PD
When used with \fB\-\-pipe\fR: Read records of \fIrecsize\fR lines.
.Sp
When used otherwise: Synonym for the \fB\-L\fR option.  Unlike \fB\-L\fR, the
\&\fIrecsize\fR argument is optional.  If \fIrecsize\fR is not specified,
it defaults to one.  The \fB\-l\fR option is deprecated since the \s-1POSIX\s0
standard specifies \fB\-L\fR instead.
.Sp
\&\fB\-l 0\fR is an alias for \fB\-l 1\fR.
.Sp
Implies \fB\-X\fR unless \fB\-m\fR, \fB\-\-xargs\fR, or \fB\-\-pipe\fR is set.
.Sp
See also: \s-1UNIT PREFIX\s0 \fB\-N\fR \fB\-\-block\fR \fB\-X\fR \fB\-m\fR
\&\fB\-\-xargs\fR \fB\-\-pipe\fR
.ie n .IP "\fB\-\-limit\fR ""\fIcommand\fR \fIargs\fR""" 4
.el .IP "\fB\-\-limit\fR ``\fIcommand\fR \fIargs\fR''" 4
.IX Item "--limit ""command args"""
Dynamic job limit.
.Sp
Before starting a new job run \fIcommand\fR with \fIargs\fR. The exit value
of \fIcommand\fR determines what \s-1GNU\s0 \fBparallel\fR will do:
.RS 4
.IP "0" 4
Below limit. Start another job.
.IP "1" 4
.IX Item "1"
Over limit. Start no jobs.
.IP "2" 4
.IX Item "2"
Way over limit. Kill the youngest job.
.RE
.RS 4
.Sp
You can use any shell command. There are 3 predefined commands:
.ie n .IP """io \fIn\fR""" 10
.el .IP "``io \fIn\fR''" 10
.IX Item """io n"""
Limit for I/O. The amount of disk I/O will be computed as a value
0\-100, where 0 is no I/O and 100 is at least one disk is 100%
saturated.
.ie n .IP """load \fIn\fR""" 10
.el .IP "``load \fIn\fR''" 10
.IX Item """load n"""
Similar to \fB\-\-load\fR.
.ie n .IP """mem \fIn\fR""" 10
.el .IP "``mem \fIn\fR''" 10
.IX Item """mem n"""
Similar to \fB\-\-memfree\fR.
.RE
.RS 4
.Sp
See also: \fB\-\-memfree\fR \fB\-\-load\fR
.RE
.IP "\fB\-\-latest\-line\fR" 4
.IX Item "--latest-line"
.PD 0
.IP "\fB\-\-ll\fR" 4
.IX Item "--ll"
.PD
Print the lastest line. Each job gets a single line that is updated
with the lastest output from the job.
.Sp
Example:
.Sp
.Vb 6
\&  slow_seq() {
\&    seq "$@" |
\&      perl \-ne \*(Aq$|=1; for(split//){ print; select($a,$a,$a,0.03);}\*(Aq
\&  }
\&  export \-f slow_seq
\&  parallel \-\-shuf \-j99 \-\-ll \-\-tag \-\-bar \-\-color slow_seq {} ::: {1..300}
.Ve
.Sp
See also: \fB\-\-line\-buffer\fR
.IP "\fB\-\-line\-buffer\fR" 4
.IX Item "--line-buffer"
.PD 0
.IP "\fB\-\-lb\fR" 4
.IX Item "--lb"
.PD
Buffer output on line basis.
.Sp
\&\fB\-\-group\fR will keep the output together for a whole job. \fB\-\-ungroup\fR
allows output to mixup with half a line coming from one job and half a
line coming from another job. \fB\-\-line\-buffer\fR fits between these two:
\&\s-1GNU\s0 \fBparallel\fR will print a full line, but will allow for mixing
lines of different jobs.
.Sp
\&\fB\-\-line\-buffer\fR takes more \s-1CPU\s0 power than both \fB\-\-group\fR and
\&\fB\-\-ungroup\fR, but can be much faster than \fB\-\-group\fR if the \s-1CPU\s0 is not
the limiting factor.
.Sp
Normally \fB\-\-line\-buffer\fR does not buffer on disk, and can thus
process an infinite amount of data, but it will buffer on disk when
combined with: \fB\-\-keep\-order\fR, \fB\-\-results\fR, \fB\-\-compress\fR, and
\&\fB\-\-files\fR. This will make it as slow as \fB\-\-group\fR and will limit
output to the available disk space.
.Sp
With \fB\-\-keep\-order\fR \fB\-\-line\-buffer\fR will output lines from the first
job continuously while it is running, then lines from the second job
while that is running. It will buffer full lines, but jobs will not
mix. Compare:
.Sp
.Vb 3
\&  parallel \-j0 \*(Aqecho [{};sleep {};echo {}]\*(Aq ::: 1 3 2 4
\&  parallel \-j0 \-\-lb \*(Aqecho [{};sleep {};echo {}]\*(Aq ::: 1 3 2 4
\&  parallel \-j0 \-k \-\-lb \*(Aqecho [{};sleep {};echo {}]\*(Aq ::: 1 3 2 4
.Ve
.Sp
See also: \fB\-\-group\fR \fB\-\-ungroup\fR \fB\-\-keep\-order\fR \fB\-\-tag\fR
.IP "\fB\-\-link\fR" 4
.IX Item "--link"
.PD 0
.IP "\fB\-\-xapply\fR" 4
.IX Item "--xapply"
.PD
Link input sources.
.Sp
Read multiple input sources like the command \fBxapply\fR. If multiple
input sources are given, one argument will be read from each of the
input sources. The arguments can be accessed in the command as \fB{1}\fR
\&.. \fB{\fR\fIn\fR\fB}\fR, so \fB{1}\fR will be a line from the first input source,
and \fB{6}\fR will refer to the line with the same line number from the
6th input source.
.Sp
Compare these two:
.Sp
.Vb 2
\&  parallel echo {1} {2} ::: 1 2 3 ::: a b c
\&  parallel \-\-link echo {1} {2} ::: 1 2 3 ::: a b c
.Ve
.Sp
Arguments will be recycled if one input source has more arguments than the others:
.Sp
.Vb 2
\&  parallel \-\-link echo {1} {2} {3} \e
\&    ::: 1 2 ::: I II III ::: a b c d e f g
.Ve
.Sp
See also: \fB\-\-header\fR \fB:::+\fR \fB::::+\fR
.IP "\fB\-\-load\fR \fImax-load\fR" 4
.IX Item "--load max-load"
Only start jobs if load is less than max-load.
.Sp
Do not start new jobs on a given computer unless the number of running
processes on the computer is less than \fImax-load\fR. \fImax-load\fR uses
the same syntax as \fB\-\-jobs\fR, so \fI100%\fR for one per \s-1CPU\s0 is a valid
setting. Only difference is 0 which is interpreted as 0.01.
.Sp
See also: \fB\-\-limit\fR \fB\-\-jobs\fR
.IP "\fB\-\-controlmaster\fR" 4
.IX Item "--controlmaster"
.PD 0
.IP "\fB\-M\fR" 4
.IX Item "-M"
.PD
Use ssh's ControlMaster to make ssh connections faster.
.Sp
Useful if jobs run remote and are very fast to run. This is disabled
for sshlogins that specify their own ssh command.
.Sp
See also: \fB\-\-ssh\fR \fB\-\-sshlogin\fR
.IP "\fB\-m\fR" 4
.IX Item "-m"
Multiple arguments.
.Sp
Insert as many arguments as the command line length permits. If
multiple jobs are being run in parallel: distribute the arguments
evenly among the jobs. Use \fB\-j1\fR or \fB\-\-xargs\fR to avoid this.
.Sp
If \fB{}\fR is not used the arguments will be appended to the
line.  If \fB{}\fR is used multiple times each \fB{}\fR will be replaced
with all the arguments.
.Sp
Support for \fB\-m\fR with \fB\-\-sshlogin\fR is limited and may fail.
.Sp
If in doubt use \fB\-X\fR as that will most likely do what is needed.
.Sp
See also: \fB\-X\fR \fB\-\-xargs\fR
.IP "\fB\-\-memfree\fR \fIsize\fR" 4
.IX Item "--memfree size"
Minimum memory free when starting another job.
.Sp
The \fIsize\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p.
.Sp
If the jobs take up very different amount of \s-1RAM, GNU\s0 \fBparallel\fR will
only start as many as there is memory for. If less than \fIsize\fR bytes
are free, no more jobs will be started. If less than 50% \fIsize\fR bytes
are free, the youngest job will be killed (as per \fB\-\-term\-seq\fR), and
put back on the queue to be run later.
.Sp
\&\fB\-\-retries\fR must be set to determine how many times \s-1GNU\s0 \fBparallel\fR
should retry a given job.
.Sp
See also: \s-1UNIT PREFIX\s0 \fB\-\-term\-seq\fR \fB\-\-retries\fR \fB\-\-memsuspend\fR
.IP "\fB\-\-memsuspend\fR \fIsize\fR" 4
.IX Item "--memsuspend size"
Suspend jobs when there is less memory available.
.Sp
If the available memory falls below 2 * \fIsize\fR, \s-1GNU\s0 \fBparallel\fR will
suspend some of the running jobs. If the available memory falls below
\&\fIsize\fR, only one job will be running.
.Sp
If a single job takes up at most \fIsize\fR \s-1RAM,\s0 all jobs will complete
without running out of memory. If you have swap available, you can
usually lower \fIsize\fR to around half the size of a single job \- with
the slight risk of swapping a little.
.Sp
Jobs will be resumed when more \s-1RAM\s0 is available \- typically when the
oldest job completes.
.Sp
\&\fB\-\-memsuspend\fR only works on local jobs because there is no obvious
way to suspend remote jobs.
.Sp
\&\fIsize\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p.
.Sp
See also: \s-1UNIT PREFIX\s0 \fB\-\-memfree\fR
.IP "\fB\-\-minversion\fR \fIversion\fR" 4
.IX Item "--minversion version"
Print the version \s-1GNU\s0 \fBparallel\fR and exit.
.Sp
If the current version of \s-1GNU\s0 \fBparallel\fR is less than \fIversion\fR the
exit code is 255. Otherwise it is 0.
.Sp
This is useful for scripts that depend on features only available from
a certain version of \s-1GNU\s0 \fBparallel\fR:
.Sp
.Vb 3
\&   parallel \-\-minversion 20170422 &&
\&     echo halt done=50% supported from version 20170422 &&
\&     parallel \-\-halt now,done=50% echo ::: {1..100}
.Ve
.Sp
See also: \fB\-\-version\fR
.IP "\fB\-\-max\-args\fR \fImax-args\fR" 4
.IX Item "--max-args max-args"
.PD 0
.IP "\fB\-n\fR \fImax-args\fR" 4
.IX Item "-n max-args"
.PD
Use at most \fImax-args\fR arguments per command line.
.Sp
Fewer than \fImax-args\fR arguments will be used if the size (see the
\&\fB\-s\fR option) is exceeded, unless the \fB\-x\fR option is given, in which
case \s-1GNU\s0 \fBparallel\fR will exit.
.Sp
\&\fB\-n 0\fR means read one argument, but insert 0 arguments on the command
line.
.Sp
\&\fImax-args\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p (see
\&\s-1UNIT PREFIX\s0).
.Sp
Implies \fB\-X\fR unless \fB\-m\fR is set.
.Sp
See also: \fB\-X\fR \fB\-m\fR \fB\-\-xargs\fR \fB\-\-max\-replace\-args\fR
.IP "\fB\-\-max\-replace\-args\fR \fImax-args\fR" 4
.IX Item "--max-replace-args max-args"
.PD 0
.IP "\fB\-N\fR \fImax-args\fR" 4
.IX Item "-N max-args"
.PD
Use at most \fImax-args\fR arguments per command line.
.Sp
Like \fB\-n\fR but also makes replacement strings \fB{1}\fR
\&.. \fB{\fR\fImax-args\fR\fB}\fR that represents argument 1 .. \fImax-args\fR. If
too few args the \fB{\fR\fIn\fR\fB}\fR will be empty.
.Sp
\&\fB\-N 0\fR means read one argument, but insert 0 arguments on the command
line.
.Sp
This will set the owner of the homedir to the user:
.Sp
.Vb 1
\&  tr \*(Aq:\*(Aq \*(Aq\en\*(Aq < /etc/passwd | parallel \-N7 chown {1} {6}
.Ve
.Sp
Implies \fB\-X\fR unless \fB\-m\fR or \fB\-\-pipe\fR is set.
.Sp
\&\fImax-args\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p.
.Sp
When used with \fB\-\-pipe\fR \fB\-N\fR is the number of records to read. This
is somewhat slower than \fB\-\-block\fR.
.Sp
See also: \s-1UNIT PREFIX\s0 \fB\-\-pipe\fR \fB\-\-block\fR \fB\-m\fR \fB\-X\fR \fB\-\-max\-args\fR
.IP "\fB\-\-nonall\fR" 4
.IX Item "--nonall"
\&\fB\-\-onall\fR with no arguments.
.Sp
Run the command on all computers given with \fB\-\-sshlogin\fR but take no
arguments. \s-1GNU\s0 \fBparallel\fR will log into \fB\-\-jobs\fR number of computers
in parallel and run the job on the computer. \fB\-j\fR adjusts how many
computers to log into in parallel.
.Sp
This is useful for running the same command (e.g. uptime) on a list of
servers.
.Sp
See also: \fB\-\-onall\fR \fB\-\-sshlogin\fR
.IP "\fB\-\-onall\fR" 4
.IX Item "--onall"
Run all the jobs on all computers given with \fB\-\-sshlogin\fR.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will log into \fB\-\-jobs\fR number of computers in
parallel and run one job at a time on the computer. The order of the
jobs will not be changed, but some computers may finish before others.
.Sp
When using \fB\-\-group\fR the output will be grouped by each server, so
all the output from one server will be grouped together.
.Sp
\&\fB\-\-joblog\fR will contain an entry for each job on each server, so
there will be several job sequence 1.
.Sp
See also: \fB\-\-nonall\fR \fB\-\-sshlogin\fR
.IP "\fB\-\-open\-tty\fR" 4
.IX Item "--open-tty"
.PD 0
.IP "\fB\-o\fR" 4
.IX Item "-o"
.PD
Open terminal tty.
.Sp
Similar to \fB\-\-tty\fR but does not set \fB\-\-jobs\fR or \fB\-\-ungroup\fR.
.Sp
See also: \fB\-\-tty\fR
.IP "\fB\-\-output\-as\-files\fR" 4
.IX Item "--output-as-files"
.PD 0
.IP "\fB\-\-outputasfiles\fR" 4
.IX Item "--outputasfiles"
.IP "\fB\-\-files\fR" 4
.IX Item "--files"
.IP "\fB\-\-files0\fR" 4
.IX Item "--files0"
.PD
Save output to files.
.Sp
Instead of printing the output to stdout (standard output) the output
of each job is saved in a file and the filename is then printed.
.Sp
\&\fB\-\-files0\fR uses \s-1NUL\s0 (\e0) instead of newline (\en) as separator.
.Sp
See also: \fB\-\-results\fR
.IP "\fB\-\-pipe\fR" 4
.IX Item "--pipe"
.PD 0
.IP "\fB\-\-spreadstdin\fR" 4
.IX Item "--spreadstdin"
.PD
Spread input to jobs on stdin (standard input).
.Sp
Read a block of data from stdin (standard input) and give one block of
data as input to one job.
.Sp
The block size is determined by \fB\-\-block\fR (default: 1M).
.Sp
Except for the first and last record \s-1GNU\s0 \fBparallel\fR only passes full
records to the job. The strings \fB\-\-recstart\fR and \fB\-\-recend\fR
determine where a record starts and ends: The border between two
records is defined as \fB\-\-recend\fR immediately followed by
\&\fB\-\-recstart\fR. \s-1GNU\s0 \fBparallel\fR splits exactly after \fB\-\-recend\fR and
before \fB\-\-recstart\fR. The block will have the last partial record
removed before the block is passed on to the job. The partial record
will be prepended to next block.
.Sp
You can limit the number of records to be passed with \fB\-N\fR, and set
the record size with \fB\-L\fR.
.Sp
\&\fB\-\-pipe\fR maxes out at around 1 GB/s input, and 100 MB/s output. If
performance is important use \fB\-\-pipe\-part\fR.
.Sp
\&\fB\-\-fifo\fR and \fB\-\-cat\fR will give stdin (standard input) on a fifo or a
temporary file.
.Sp
If data is arriving slowly, you can use \fB\-\-block\-timeout\fR to finish
reading a block early.
.Sp
The data can be spread between the jobs in specific ways using
\&\fB\-\-round\-robin\fR, \fB\-\-bin\fR, \fB\-\-shard\fR, \fB\-\-group\-by\fR. See the
section: \s-1SPREADING BLOCKS OF DATA\s0
.Sp
See also: \fB\-\-block\fR \fB\-\-block\-timeout\fR \fB\-\-recstart\fR \fB\-\-recend\fR
\&\fB\-\-fifo\fR \fB\-\-cat\fR \fB\-\-pipe\-part\fR \fB\-N\fR \fB\-L\fR \fB\-\-round\-robin\fR
.IP "\fB\-\-pipe\-part\fR" 4
.IX Item "--pipe-part"
Pipe parts of a physical file.
.Sp
\&\fB\-\-pipe\-part\fR works similar to \fB\-\-pipe\fR, but is much faster. 5 GB/s
can easily be delivered.
.Sp
\&\fB\-\-pipe\-part\fR has a few limitations:
.RS 4
.IP "\(bu" 3
The file must be a normal file or a block device (technically it must
be seekable) and must be given using \fB\-\-arg\-file\fR or \fB::::\fR. The file cannot
be a pipe, a fifo, or a stream as they are not seekable.
.Sp
If using a block device with lot of \s-1NUL\s0 bytes, remember to set
\&\fB\-\-recend ''\fR.
.IP "\(bu" 3
Record counting (\fB\-N\fR) and line counting (\fB\-L\fR/\fB\-l\fR) do not
work. Instead use \fB\-\-recstart\fR and \fB\-\-recend\fR to determine
where records end.
.RE
.RS 4
.Sp
See also: \fB\-\-pipe\fR \fB\-\-recstart\fR \fB\-\-recend\fR \fB\-\-arg\-file\fR \fB::::\fR
.RE
.IP "\fB\-\-plain\fR" 4
.IX Item "--plain"
Ignore \fB\-\-profile\fR, \f(CW$PARALLEL\fR, and ~/.parallel/config.
.Sp
Ignore any \fB\-\-profile\fR, \f(CW$PARALLEL\fR, and ~/.parallel/config to get full
control on the command line (used by \s-1GNU\s0 \fBparallel\fR internally when
called with \fB\-\-sshlogin\fR).
.Sp
See also: \fB\-\-profile\fR
.IP "\fB\-\-plus\fR" 4
.IX Item "--plus"
Add more replacement strings.
.Sp
Activate additional replacement strings: {+/} {+.} {+..} {+...} {..}
{...} {/..} {/...} {##}. The idea being that '{+foo}' matches the
opposite of '{foo}' so that:
.Sp
{} = {+/}/{/} = {.}.{+.} = {+/}/{/.}.{+.}  = {..}.{+..} =
{+/}/{/..}.{+..} = {...}.{+...} = {+/}/{/...}.{+...}
.Sp
\&\fB{##}\fR is the total number of jobs to be run. It is incompatible with
\&\fB\-X\fR/\fB\-m\fR/\fB\-\-xargs\fR.
.Sp
\&\fB{0%}\fR zero-padded jobslot.
.Sp
\&\fB{0#}\fR zero-padded sequence number.
.Sp
\&\fB{choose_k}\fR is inspired by n choose k: Given a list of n elements,
choose k. k is the number of input sources and n is the number of
arguments in an input source.  The content of the input sources must
be the same and the arguments must be unique.
.Sp
\&\fB{uniq}\fR skips jobs where values from two input sources are the same.
.Sp
Shorthands for variables:
.Sp
.Vb 5
\&  {slot}         $PARALLEL_JOBSLOT (see {%})
\&  {sshlogin}     $PARALLEL_SSHLOGIN
\&  {host}         $PARALLEL_SSHHOST
\&  {agrp}         $PARALLEL_ARGHOSTGROUPS
\&  {hgrp}         $PARALLEL_HOSTGROUPS
.Ve
.Sp
The following dynamic replacement strings are also activated. They are
inspired by bash's parameter expansion:
.Sp
.Vb 10
\&  {:\-str}        str if the value is empty
\&  {:num}         remove the first num characters
\&  {:pos:len}     substring from position pos length len
\&  {#regexp}      remove prefix regexp (non\-greedy)
\&  {##regexp}     remove prefix regexp (greedy)
\&  {%regexp}      remove postfix regexp (non\-greedy)
\&  {%%regexp}     remove postfix regexp (greedy)
\&  {/regexp/str}  replace one regexp with str
\&  {//regexp/str} replace every regexp with str
\&  {^str}         uppercase str if found at the start
\&  {^^str}        uppercase str
\&  {,str}         lowercase str if found at the start
\&  {,,str}        lowercase str
.Ve
.Sp
See also: \fB\-\-rpl\fR \fB{}\fR
.IP "\fB\-\-process\-slot\-var\fR \fIvarname\fR" 4
.IX Item "--process-slot-var varname"
Set the environment variable \fIvarname\fR to the jobslot number\-1.
.Sp
.Vb 1
\&  seq 10 | parallel \-\-process\-slot\-var=name echo \*(Aq$name\*(Aq {}
.Ve
.IP "\fB\-\-progress\fR" 4
.IX Item "--progress"
Show progress of computations.
.Sp
List the computers involved in the task with number of CPUs detected
and the max number of jobs to run. After that show progress for each
computer: number of running jobs, number of completed jobs, and
percentage of all jobs done by this computer. The percentage will only
be available after all jobs have been scheduled as \s-1GNU\s0 \fBparallel\fR
only read the next job when ready to schedule it \- this is to avoid
wasting time and memory by reading everything at startup.
.Sp
By sending \s-1GNU\s0 \fBparallel\fR \s-1SIGUSR2\s0 you can toggle turning on/off
\&\fB\-\-progress\fR on a running \s-1GNU\s0 \fBparallel\fR process.
.Sp
See also: \fB\-\-eta\fR \fB\-\-bar\fR
.IP "\fB\-\-max\-line\-length\-allowed\fR" 4
.IX Item "--max-line-length-allowed"
Print maximal command line length.
.Sp
Print the maximal number of characters allowed on the command line and
exit (used by \s-1GNU\s0 \fBparallel\fR itself to determine the line length
on remote computers).
.Sp
See also: \fB\-\-show\-limits\fR
.IP "\fB\-\-number\-of\-cpus\fR (obsolete)" 4
.IX Item "--number-of-cpus (obsolete)"
Print the number of physical \s-1CPU\s0 cores and exit.
.IP "\fB\-\-number\-of\-cores\fR" 4
.IX Item "--number-of-cores"
Print the number of physical \s-1CPU\s0 cores and exit (used by \s-1GNU\s0 \fBparallel\fR itself
to determine the number of physical \s-1CPU\s0 cores on remote computers).
.Sp
See also: \fB\-\-number\-of\-sockets\fR \fB\-\-number\-of\-threads\fR
\&\fB\-\-use\-cores\-instead\-of\-threads\fR \fB\-\-jobs\fR
.IP "\fB\-\-number\-of\-sockets\fR" 4
.IX Item "--number-of-sockets"
Print the number of filled \s-1CPU\s0 sockets and exit (used by \s-1GNU\s0
\&\fBparallel\fR itself to determine the number of filled \s-1CPU\s0 sockets on
remote computers).
.Sp
See also: \fB\-\-number\-of\-cores\fR \fB\-\-number\-of\-threads\fR
\&\fB\-\-use\-sockets\-instead\-of\-threads\fR \fB\-\-jobs\fR
.IP "\fB\-\-number\-of\-threads\fR" 4
.IX Item "--number-of-threads"
Print the number of hyperthreaded \s-1CPU\s0 cores and exit (used by \s-1GNU\s0
\&\fBparallel\fR itself to determine the number of hyperthreaded \s-1CPU\s0 cores
on remote computers).
.Sp
See also: \fB\-\-number\-of\-cores\fR \fB\-\-number\-of\-sockets\fR \fB\-\-jobs\fR
.IP "\fB\-\-no\-keep\-order\fR" 4
.IX Item "--no-keep-order"
Overrides an earlier \fB\-\-keep\-order\fR (e.g. if set in
\&\fB~/.parallel/config\fR).
.IP "\fB\-\-nice\fR \fIniceness\fR" 4
.IX Item "--nice niceness"
Run the command at this niceness.
.Sp
By default \s-1GNU\s0 \fBparallel\fR will run jobs at the same nice level as \s-1GNU\s0
\&\fBparallel\fR is started \- both on the local machine and remote servers,
so you are unlikely to ever use this option.
.Sp
Setting \fB\-\-nice\fR will override this nice level. If the nice level is
smaller than the current nice level, it will only affect remote jobs
(e.g. if current level is 10 then \fB\-\-nice 5\fR will cause local jobs to
be run at level 10, but remote jobs run at nice level 5).
.IP "\fB\-\-interactive\fR" 4
.IX Item "--interactive"
.PD 0
.IP "\fB\-p\fR" 4
.IX Item "-p"
.PD
Ask user before running a job.
.Sp
Prompt the user about whether to run each command line and read a line
from the terminal.  Only run the command line if the response starts
with 'y' or 'Y'.  Implies \fB\-t\fR.
.IP "\fB\-\-_parset\fR \fItype\fR,\fIvarname\fR" 4
.IX Item "--_parset type,varname"
Used internally by \fBparset\fR.
.Sp
Generate shell code to be eval'ed which will set the variable(s)
\&\fIvarname\fR. \fItype\fR can be 'assoc' for associative array or 'var' for
normal variables.
.Sp
The only supported use is as part of \fBparset\fR.
.IP "\fB\-\-parens\fR \fIparensstring\fR" 4
.IX Item "--parens parensstring"
Use \fIparensstring\fR instead of \fB{==}\fR.
.Sp
Define start and end parenthesis for \fB{=perl expression=}\fR. The
left and the right parenthesis can be multiple characters and are
assumed to be the same length. The default is \fB{==}\fR giving \fB{=\fR as
the start parenthesis and \fB=}\fR as the end parenthesis.
.Sp
Another useful setting is \fB,,,,\fR which would make both parenthesis
\&\fB,,\fR:
.Sp
.Vb 1
\&  parallel \-\-parens ,,,, echo foo is ,,s/I/O/g,, ::: FII
.Ve
.Sp
See also: \fB\-\-rpl\fR \fB{=\fR\fIperl expression\fR\fB=}\fR
.IP "\fB\-\-profile\fR \fIprofilename\fR" 4
.IX Item "--profile profilename"
.PD 0
.IP "\fB\-J\fR \fIprofilename\fR" 4
.IX Item "-J profilename"
.PD
Use profile \fIprofilename\fR for options.
.Sp
This is useful if you want to have multiple profiles. You could have
one profile for running jobs in parallel on the local computer and a
different profile for running jobs on remote computers.
.Sp
\&\fIprofilename\fR corresponds to the file ~/.parallel/\fIprofilename\fR.
.Sp
You can give multiple profiles by repeating \fB\-\-profile\fR. If parts of
the profiles conflict, the later ones will be used.
.Sp
Default: ~/.parallel/config
.Sp
See also: \s-1PROFILE FILES\s0
.IP "\fB\-\-quote\fR" 4
.IX Item "--quote"
.PD 0
.IP "\fB\-q\fR" 4
.IX Item "-q"
.PD
Quote \fIcommand\fR.
.Sp
If your command contains special characters that should not be
interpreted by the shell (e.g. ; \e | *), use \fB\-\-quote\fR to escape
these. The command must be a simple command (see \fBman bash\fR) without
redirections and without variable assignments.
.Sp
Most people will not need this. Quoting is disabled by default.
.Sp
See also: \s-1QUOTING\s0 \fIcommand\fR \fB\-\-shell\-quote\fR \fB\fBuq()\fB\fR \fBQ()\fR
.IP "\fB\-\-no\-run\-if\-empty\fR" 4
.IX Item "--no-run-if-empty"
.PD 0
.IP "\fB\-r\fR" 4
.IX Item "-r"
.PD
Do not run empty input.
.Sp
If the stdin (standard input) only contains whitespace, do not run the
command.
.Sp
If used with \fB\-\-pipe\fR this is slow.
.Sp
See also: \fIcommand\fR \fB\-\-pipe\fR \fB\-\-interactive\fR
.IP "\fB\-\-noswap\fR" 4
.IX Item "--noswap"
Do not start job is computer is swapping.
.Sp
Do not start new jobs on a given computer if there is both swap-in and
swap-out activity.
.Sp
The swap activity is only sampled every 10 seconds as the sampling
takes 1 second to do.
.Sp
Swap activity is computed as (swap\-in)*(swap\-out) which in practice is
a good value: swapping out is not a problem, swapping in is not a
problem, but both swapping in and out usually indicates a problem.
.Sp
\&\fB\-\-memfree\fR and \fB\-\-memsuspend\fR may give better results, so try using
those first.
.Sp
See also: \fB\-\-memfree\fR \fB\-\-memsuspend\fR
.IP "\fB\-\-record\-env\fR" 4
.IX Item "--record-env"
Record exported environment.
.Sp
Record current exported environment variables in
\&\fB~/.parallel/ignored_vars\fR.  This will ignore variables currently set
when using \fB\-\-env _\fR. So you should set the variables/fuctions, you
want to use \fIafter\fR running \fB\-\-record\-env\fR.
.Sp
See also: \fB\-\-env\fR \fB\-\-session\fR \fBenv_parallel\fR
.IP "\fB\-\-recstart\fR \fIstartstring\fR" 4
.IX Item "--recstart startstring"
.PD 0
.IP "\fB\-\-recend\fR \fIendstring\fR" 4
.IX Item "--recend endstring"
.PD
Split record between \fIendstring\fR and \fIstartstring\fR.
.Sp
If \fB\-\-recstart\fR is given \fIstartstring\fR will be used to split at record start.
.Sp
If \fB\-\-recend\fR is given \fIendstring\fR will be used to split at record end.
.Sp
If both \fB\-\-recstart\fR and \fB\-\-recend\fR are given the combined string
\&\fIendstring\fR\fIstartstring\fR will have to match to find a split
position. This is useful if either \fIstartstring\fR or \fIendstring\fR
match in the middle of a record.
.Sp
If neither \fB\-\-recstart\fR nor \fB\-\-recend\fR are given, then \fB\-\-recend\fR
defaults to '\en'. To have no record separator (e.g. for binary files)
use \fB\-\-recend ""\fR.
.Sp
\&\fB\-\-recstart\fR and \fB\-\-recend\fR are used with \fB\-\-pipe\fR.
.Sp
Use \fB\-\-regexp\fR to interpret \fB\-\-recstart\fR and \fB\-\-recend\fR as regular
expressions. This is slow, however.
.Sp
Use \fB\-\-remove\-rec\-sep\fR to remove \fB\-\-recstart\fR and \fB\-\-recend\fR before
passing the block to the job.
.Sp
See also: \fB\-\-pipe\fR \fB\-\-regexp\fR \fB\-\-remove\-rec\-sep\fR
.IP "\fB\-\-regexp\fR" 4
.IX Item "--regexp"
Use \fB\-\-regexp\fR to interpret \fB\-\-recstart\fR and \fB\-\-recend\fR as regular
expressions. This is slow, however.
.Sp
See also: \fB\-\-pipe\fR \fB\-\-regexp\fR \fB\-\-remove\-rec\-sep\fR \fB\-\-recstart\fR
\&\fB\-\-recend\fR
.IP "\fB\-\-remove\-rec\-sep\fR" 4
.IX Item "--remove-rec-sep"
.PD 0
.IP "\fB\-\-removerecsep\fR" 4
.IX Item "--removerecsep"
.IP "\fB\-\-rrs\fR" 4
.IX Item "--rrs"
.PD
Remove record separator.
.Sp
Remove the text matched by \fB\-\-recstart\fR and \fB\-\-recend\fR before piping
it to the command.
.Sp
Only used with \fB\-\-pipe\fR/\fB\-\-pipe\-part\fR.
.Sp
See also: \fB\-\-pipe\fR \fB\-\-regexp\fR \fB\-\-pipe\-part\fR \fB\-\-recstart\fR
\&\fB\-\-recend\fR
.IP "\fB\-\-results\fR \fIname\fR" 4
.IX Item "--results name"
.PD 0
.IP "\fB\-\-res\fR \fIname\fR" 4
.IX Item "--res name"
.PD
Save the output into files.
.Sp
\&\fBSimple string output dir\fR
.Sp
If \fIname\fR does not contain replacement strings and does not end in
\&\fB.csv/.tsv\fR, the output will be stored in a directory tree rooted at
\&\fIname\fR.  Within this directory tree, each command will result in
three files: \fIname\fR/<\s-1ARGS\s0>/stdout and \fIname\fR/<\s-1ARGS\s0>/stderr,
\&\fIname\fR/<\s-1ARGS\s0>/seq, where <\s-1ARGS\s0> is a sequence of directories
representing the header of the input source (if using \fB\-\-header :\fR)
or the number of the input source and corresponding values.
.Sp
E.g:
.Sp
.Vb 2
\&  parallel \-\-header : \-\-results foo echo {a} {b} \e
\&    ::: a I II ::: b III IIII
.Ve
.Sp
will generate the files:
.Sp
.Vb 12
\&  foo/a/II/b/III/seq
\&  foo/a/II/b/III/stderr
\&  foo/a/II/b/III/stdout
\&  foo/a/II/b/IIII/seq
\&  foo/a/II/b/IIII/stderr
\&  foo/a/II/b/IIII/stdout
\&  foo/a/I/b/III/seq
\&  foo/a/I/b/III/stderr
\&  foo/a/I/b/III/stdout
\&  foo/a/I/b/IIII/seq
\&  foo/a/I/b/IIII/stderr
\&  foo/a/I/b/IIII/stdout
.Ve
.Sp
and
.Sp
.Vb 1
\&  parallel \-\-results foo echo {1} {2} ::: I II ::: III IIII
.Ve
.Sp
will generate the files:
.Sp
.Vb 12
\&  foo/1/II/2/III/seq
\&  foo/1/II/2/III/stderr
\&  foo/1/II/2/III/stdout
\&  foo/1/II/2/IIII/seq
\&  foo/1/II/2/IIII/stderr
\&  foo/1/II/2/IIII/stdout
\&  foo/1/I/2/III/seq
\&  foo/1/I/2/III/stderr
\&  foo/1/I/2/III/stdout
\&  foo/1/I/2/IIII/seq
\&  foo/1/I/2/IIII/stderr
\&  foo/1/I/2/IIII/stdout
.Ve
.Sp
\&\fB\s-1CSV\s0 file output\fR
.Sp
If \fIname\fR ends in \fB.csv\fR/\fB.tsv\fR the output will be a CSV-file
named \fIname\fR.
.Sp
\&\fB.csv\fR gives a comma separated value file. \fB.tsv\fR gives a \s-1TAB\s0
separated value file.
.Sp
\&\fB\-.csv\fR/\fB\-.tsv\fR are special: It will give the file on stdout
(standard output).
.Sp
\&\fB\s-1JSON\s0 file output\fR
.Sp
If \fIname\fR ends in \fB.json\fR the output will be a JSON-file
named \fIname\fR.
.Sp
\&\fB\-.json\fR is special: It will give the file on stdout (standard
output).
.Sp
\&\fBReplacement string output file\fR
.Sp
If \fIname\fR contains a replacement string and the replaced result does
not end in /, then the standard output will be stored in a file named
by this result. Standard error will be stored in the same file name
with '.err' added, and the sequence number will be stored in the same
file name with '.seq' added.
.Sp
E.g.
.Sp
.Vb 1
\&  parallel \-\-results my_{} echo ::: foo bar baz
.Ve
.Sp
will generate the files:
.Sp
.Vb 9
\&  my_bar
\&  my_bar.err
\&  my_bar.seq
\&  my_baz
\&  my_baz.err
\&  my_baz.seq
\&  my_foo
\&  my_foo.err
\&  my_foo.seq
.Ve
.Sp
\&\fBReplacement string output dir\fR
.Sp
If \fIname\fR contains a replacement string and the replaced result ends
in /, then output files will be stored in the resulting dir.
.Sp
E.g.
.Sp
.Vb 1
\&  parallel \-\-results my_{}/ echo ::: foo bar baz
.Ve
.Sp
will generate the files:
.Sp
.Vb 9
\&  my_bar/seq
\&  my_bar/stderr
\&  my_bar/stdout
\&  my_baz/seq
\&  my_baz/stderr
\&  my_baz/stdout
\&  my_foo/seq
\&  my_foo/stderr
\&  my_foo/stdout
.Ve
.Sp
See also: \fB\-\-output\-as\-files\fR \fB\-\-tag\fR \fB\-\-header\fR \fB\-\-joblog\fR
.IP "\fB\-\-resume\fR" 4
.IX Item "--resume"
Resumes from the last unfinished job.
.Sp
By reading \fB\-\-joblog\fR or the
\&\fB\-\-results\fR dir \s-1GNU\s0 \fBparallel\fR will figure out the last unfinished
job and continue from there. As \s-1GNU\s0 \fBparallel\fR only looks at the
sequence numbers in \fB\-\-joblog\fR then the input, the command, and
\&\fB\-\-joblog\fR all have to remain unchanged; otherwise \s-1GNU\s0 \fBparallel\fR
may run wrong commands.
.Sp
See also: \fB\-\-joblog\fR \fB\-\-results\fR \fB\-\-resume\-failed\fR \fB\-\-retries\fR
.IP "\fB\-\-resume\-failed\fR" 4
.IX Item "--resume-failed"
Retry all failed and resume from the last unfinished job.
.Sp
By reading
\&\fB\-\-joblog\fR \s-1GNU\s0 \fBparallel\fR will figure out the failed jobs and run
those again. After that it will resume last unfinished job and
continue from there. As \s-1GNU\s0 \fBparallel\fR only looks at the sequence
numbers in \fB\-\-joblog\fR then the input, the command, and \fB\-\-joblog\fR
all have to remain unchanged; otherwise \s-1GNU\s0 \fBparallel\fR may run wrong
commands.
.Sp
See also: \fB\-\-joblog\fR \fB\-\-resume\fR \fB\-\-retry\-failed\fR \fB\-\-retries\fR
.IP "\fB\-\-retry\-failed\fR" 4
.IX Item "--retry-failed"
Retry all failed jobs in joblog.
.Sp
By reading \fB\-\-joblog\fR \s-1GNU\s0
\&\fBparallel\fR will figure out the failed jobs and run those again.
.Sp
\&\fB\-\-retry\-failed\fR ignores the command and arguments on the command
line: It only looks at the joblog.
.Sp
\&\fBDifferences between \-\-resume, \-\-resume\-failed, \-\-retry\-failed\fR
.Sp
In this example \fBexit {= \f(CB$_\fB%=2 =}\fR will cause every other job to fail.
.Sp
.Vb 2
\&  timeout \-k 1 4 parallel \-\-joblog log \-j10 \e
\&    \*(Aqsleep {}; exit {= $_%=2 =}\*(Aq ::: {10..1}
.Ve
.Sp
4 jobs completed. 2 failed:
.Sp
.Vb 5
\&  Seq   [...]   Exitval Signal  Command
\&  10    [...]   1       0       sleep 1; exit 1
\&  9     [...]   0       0       sleep 2; exit 0
\&  8     [...]   1       0       sleep 3; exit 1
\&  7     [...]   0       0       sleep 4; exit 0
.Ve
.Sp
\&\fB\-\-resume\fR does not care about the Exitval, but only looks at Seq. If
the Seq is run, it will not be run again. So if needed, you can change
the command for the seqs not run yet:
.Sp
.Vb 2
\&  parallel \-\-resume \-\-joblog log \-j10 \e
\&    \*(Aqsleep .{}; exit {= $_%=2 =}\*(Aq ::: {10..1}
\&
\&  Seq   [...]   Exitval Signal  Command
\&  [... as above ...]
\&  1     [...]   0       0       sleep .10; exit 0
\&  6     [...]   1       0       sleep .5; exit 1
\&  5     [...]   0       0       sleep .6; exit 0
\&  4     [...]   1       0       sleep .7; exit 1
\&  3     [...]   0       0       sleep .8; exit 0
\&  2     [...]   1       0       sleep .9; exit 1
.Ve
.Sp
\&\fB\-\-resume\-failed\fR cares about the Exitval, but also only looks at Seq
to figure out which commands to run. Again this means you can change
the command, but not the arguments. It will run the failed seqs and
the seqs not yet run:
.Sp
.Vb 2
\&  parallel \-\-resume\-failed \-\-joblog log \-j10 \e
\&    \*(Aqecho {};sleep .{}; exit {= $_%=3 =}\*(Aq ::: {10..1}
\&
\&  Seq   [...]   Exitval Signal  Command
\&  [... as above ...]
\&  10    [...]   1       0       echo 1;sleep .1; exit 1
\&  8     [...]   0       0       echo 3;sleep .3; exit 0
\&  6     [...]   2       0       echo 5;sleep .5; exit 2
\&  4     [...]   1       0       echo 7;sleep .7; exit 1
\&  2     [...]   0       0       echo 9;sleep .9; exit 0
.Ve
.Sp
\&\fB\-\-retry\-failed\fR cares about the Exitval, but takes the command from
the joblog. It ignores any arguments or commands given on the command
line:
.Sp
.Vb 1
\&  parallel \-\-retry\-failed \-\-joblog log \-j10 this part is ignored
\&
\&  Seq   [...]   Exitval Signal  Command
\&  [... as above ...]
\&  10    [...]   1       0       echo 1;sleep .1; exit 1
\&  6     [...]   2       0       echo 5;sleep .5; exit 2
\&  4     [...]   1       0       echo 7;sleep .7; exit 1
.Ve
.Sp
See also: \fB\-\-joblog\fR \fB\-\-resume\fR \fB\-\-resume\-failed\fR \fB\-\-retries\fR
.IP "\fB\-\-retries\fR \fIn\fR" 4
.IX Item "--retries n"
Try failing jobs \fIn\fR times.
.Sp
If a job fails, retry it on another computer on which it has not
failed. Do this \fIn\fR times. If there are fewer than \fIn\fR computers in
\&\fB\-\-sshlogin\fR \s-1GNU\s0 \fBparallel\fR will re-use all the computers. This is
useful if some jobs fail for no apparent reason (such as network
failure).
.Sp
\&\fIn\fR=0 means infinite.
.Sp
See also: \fB\-\-term\-seq\fR \fB\-\-sshlogin\fR
.IP "\fB\-\-return\fR \fIfilename\fR" 4
.IX Item "--return filename"
Transfer files from remote computers.
.Sp
\&\fB\-\-return\fR is used with
\&\fB\-\-sshlogin\fR when the arguments are files on the remote computers. When
processing is done the file \fIfilename\fR will be transferred
from the remote computer using \fBrsync\fR and will be put relative to
the default login dir. E.g.
.Sp
.Vb 2
\&  echo foo/bar.txt | parallel \-\-return {.}.out \e
\&    \-\-sshlogin server.example.com touch {.}.out
.Ve
.Sp
This will transfer the file \fI\f(CI$HOME\fI/foo/bar.out\fR from the computer
\&\fIserver.example.com\fR to the file \fIfoo/bar.out\fR after running
\&\fBtouch foo/bar.out\fR on \fIserver.example.com\fR.
.Sp
.Vb 1
\&  parallel \-S server \-\-trc out/./{}.out touch {}.out ::: in/file
.Ve
.Sp
This will transfer the file \fIin/file.out\fR from the computer
\&\fIserver.example.com\fR to the files \fIout/in/file.out\fR after running
\&\fBtouch in/file.out\fR on \fIserver\fR.
.Sp
.Vb 2
\&  echo /tmp/foo/bar.txt | parallel \-\-return {.}.out \e
\&    \-\-sshlogin server.example.com touch {.}.out
.Ve
.Sp
This will transfer the file \fI/tmp/foo/bar.out\fR from the computer
\&\fIserver.example.com\fR to the file \fI/tmp/foo/bar.out\fR after running
\&\fBtouch /tmp/foo/bar.out\fR on \fIserver.example.com\fR.
.Sp
Multiple files can be transferred by repeating the option multiple
times:
.Sp
.Vb 3
\&  echo /tmp/foo/bar.txt | parallel \e
\&    \-\-sshlogin server.example.com \e
\&    \-\-return {.}.out \-\-return {.}.out2 touch {.}.out {.}.out2
.Ve
.Sp
\&\fB\-\-return\fR is ignored when used with \fB\-\-sshlogin :\fR or when not used
with \fB\-\-sshlogin\fR.
.Sp
For details on transferring see \fB\-\-transferfile\fR.
.Sp
See also: \fB\-\-transfer\fR \fB\-\-transferfile\fR \fB\-\-sshlogin\fR \fB\-\-cleanup\fR
\&\fB\-\-workdir\fR
.IP "\fB\-\-round\-robin\fR" 4
.IX Item "--round-robin"
.PD 0
.IP "\fB\-\-round\fR" 4
.IX Item "--round"
.PD
Distribute chunks of standard input in a round robin fashion.
.Sp
Normally \fB\-\-pipe\fR will give a single block to each instance of the
command. With \fB\-\-round\-robin\fR all blocks will at random be written to
commands already running. This is useful if the command takes a long
time to initialize.
.Sp
With \fB\-\-keep\-order\fR and \fB\-\-round\-robin\fR the jobslots will get the
same blocks as input in the same order in every run if the input is
kept the same. See details under \fB\-\-keep\-order\fR.
.Sp
\&\fB\-\-round\-robin\fR implies \fB\-\-pipe\fR, except if \fB\-\-pipe\-part\fR is given.
.Sp
See the section: \s-1SPREADING BLOCKS OF DATA.\s0
.Sp
See also: \fB\-\-bin\fR \fB\-\-group\-by\fR \fB\-\-shard\fR
.IP "\fB\-\-rpl\fR '\fItag\fR \fIperl expression\fR'" 4
.IX Item "--rpl 'tag perl expression'"
Define replacement string.
.Sp
Use \fItag\fR as a replacement string for \fIperl expression\fR. This makes
it possible to define your own replacement strings. \s-1GNU\s0 \fBparallel\fR's
7 replacement strings are implemented as:
.Sp
.Vb 8
\&  \-\-rpl \*(Aq{} \*(Aq
\&  \-\-rpl \*(Aq{#} 1 $_=$job\->seq()\*(Aq
\&  \-\-rpl \*(Aq{%} 1 $_=$job\->slot()\*(Aq
\&  \-\-rpl \*(Aq{/} s:.*/::\*(Aq
\&  \-\-rpl \*(Aq{//} $Global::use{"File::Basename"} ||=
\&              eval "use File::Basename; 1;"; $_ = dirname($_);\*(Aq
\&  \-\-rpl \*(Aq{/.} s:.*/::; s:\e.[^/.]+$::;\*(Aq
\&  \-\-rpl \*(Aq{.} s:\e.[^/.]+$::\*(Aq
.Ve
.Sp
The \fB\-\-plus\fR replacement strings are implemented as:
.Sp
.Vb 10
\&  \-\-rpl \*(Aq{+/} s:/[^/]*$:: || s:.*$::\*(Aq
\&  \-\-rpl \*(Aq{+.} s:.*\e.:: || s:.*$::\*(Aq
\&  \-\-rpl \*(Aq{+..} s:.*\e.([^/.]+\e.[^/.]+)$:$1: || s:.*$::\*(Aq
\&  \-\-rpl \*(Aq{+...} s:.*\e.([^/.]+\e.[^/.]+\e.[^/.]+)$:$1: || s:.*$::\*(Aq
\&  \-\-rpl \*(Aq{..} s:\e.[^/.]+\e.[^/.]+$::\*(Aq
\&  \-\-rpl \*(Aq{...} s:\e.[^/.]+\e.[^/.]+\e.[^/.]+$::\*(Aq
\&  \-\-rpl \*(Aq{/..} s:.*/::; s:\e.[^/.]+\e.[^/.]+$::\*(Aq
\&  \-\-rpl \*(Aq{/...} s:.*/::; s:\e.[^/.]+\e.[^/.]+\e.[^/.]+$::\*(Aq
\&  \-\-rpl \*(Aq{choose_k}
\&         for $t (2..$#arg){ if($arg[$t\-1] ge $arg[$t]) { skip() } }\*(Aq
\&  \-\-rpl \*(Aq{##} 1 $_=total_jobs()\*(Aq
\&  \-\-rpl \*(Aq{0%} 1 $f=1+int((log($Global::max_jobs_running||1)/
\&                          log(10))); $_=sprintf("%0${f}d",slot())\*(Aq
\&  \-\-rpl \*(Aq{0#} 1 $f=1+int((log(total_jobs())/log(10)));
\&              $_=sprintf("%0${f}d",seq())\*(Aq
\&
\&  \-\-rpl \*(Aq{:\-([^}]+?)} $_ ||= $$1\*(Aq
\&  \-\-rpl \*(Aq{:(\ed+?)} substr($_,0,$$1) = ""\*(Aq
\&  \-\-rpl \*(Aq{:(\ed+?):(\ed+?)} $_ = substr($_,$$1,$$2);\*(Aq
\&  \-\-rpl \*(Aq{#([^#}][^}]*?)} $nongreedy=::make_regexp_ungreedy($$1);
\&                          s/^$nongreedy(.*)/$1/;\*(Aq
\&  \-\-rpl \*(Aq{##([^#}][^}]*?)} s/^$$1//;\*(Aq
\&  \-\-rpl \*(Aq{%([^}]+?)} $nongreedy=::make_regexp_ungreedy($$1);
\&                     s/(.*)$nongreedy$/$1/;\*(Aq
\&  \-\-rpl \*(Aq{%%([^}]+?)} s/$$1$//;\*(Aq
\&  \-\-rpl \*(Aq{/([^}]+?)/([^}]*?)} s/$$1/$$2/;\*(Aq
\&  \-\-rpl \*(Aq{^([^}]+?)} s/^($$1)/uc($1)/e;\*(Aq
\&  \-\-rpl \*(Aq{^^([^}]+?)} s/($$1)/uc($1)/eg;\*(Aq
\&  \-\-rpl \*(Aq{,([^}]+?)} s/^($$1)/lc($1)/e;\*(Aq
\&  \-\-rpl \*(Aq{,,([^}]+?)} s/($$1)/lc($1)/eg;\*(Aq
\&
\&  \-\-rpl \*(Aq{slot} 1 $_="\e${PARALLEL_JOBSLOT}";uq()\*(Aq
\&  \-\-rpl \*(Aq{host} 1 $_="\e${PARALLEL_SSHHOST}";uq()\*(Aq
\&  \-\-rpl \*(Aq{sshlogin} 1 $_="\e${PARALLEL_SSHLOGIN}";uq()\*(Aq
\&  \-\-rpl \*(Aq{hgrp} 1 $_="\e${PARALLEL_HOSTGROUPS}";uq()\*(Aq
\&  \-\-rpl \*(Aq{agrp} 1 $_="\e${PARALLEL_ARGHOSTGROUPS}";uq()\*(Aq
.Ve
.Sp
If the user defined replacement string starts with '{' it can also be
used as a positional replacement string (like \fB{2.}\fR).
.Sp
It is recommended to only change \f(CW$_\fR but you have full access to all
of \s-1GNU\s0 \fBparallel\fR's internal functions and data structures.
.Sp
Here are a few examples:
.Sp
.Vb 11
\&  Is the job sequence even or odd?
\&  \-\-rpl \*(Aq{odd} $_ = seq() % 2 ? "odd" : "even"\*(Aq
\&  Pad job sequence with leading zeros to get equal width
\&  \-\-rpl \*(Aq{0#} $f=1+int("".(log(total_jobs())/log(10)));
\&    $_=sprintf("%0${f}d",seq())\*(Aq
\&  Job sequence counting from 0
\&  \-\-rpl \*(Aq{#0} $_ = seq() \- 1\*(Aq
\&  Job slot counting from 2
\&  \-\-rpl \*(Aq{%1} $_ = slot() + 1\*(Aq
\&  Remove all extensions
\&  \-\-rpl \*(Aq{:} s:(\e.[^/]+)*$::\*(Aq
.Ve
.Sp
You can have dynamic replacement strings by including parenthesis in
the replacement string and adding a regular expression between the
parenthesis. The matching string will be inserted as $$1:
.Sp
.Vb 5
\&  parallel \-\-rpl \*(Aq{%(.*?)} s/$$1//\*(Aq echo {%.tar.gz} ::: my.tar.gz
\&  parallel \-\-rpl \*(Aq{:%(.+?)} s:$$1(\e.[^/]+)*$::\*(Aq \e
\&    echo {:%_file} ::: my_file.tar.gz
\&  parallel \-n3 \-\-rpl \*(Aq{/:%(.*?)} s:.*/(.*)$$1(\e.[^/]+)*$:$1:\*(Aq \e
\&    echo job {#}: {2} {2.} {3/:%_1} ::: a/b.c c/d.e f/g_1.h.i
.Ve
.Sp
You can even use multiple matches:
.Sp
.Vb 2
\&  parallel \-\-rpl \*(Aq{/(.+?)/(.*?)} s/$$1/$$2/;\*(Aq
\&    echo {/replacethis/withthis} {/b/C} ::: a_replacethis_b
\&
\&  parallel \-\-rpl \*(Aq{(.*?)/(.*?)} $_="$$2$_$$1"\*(Aq \e
\&    echo {swap/these} ::: \-middle\-
.Ve
.Sp
See also: \fB{=\fR\fIperl expression\fR\fB=}\fR \fB\-\-parens\fR
.IP "\fB\-\-rsync\-opts\fR \fIoptions\fR" 4
.IX Item "--rsync-opts options"
Options to pass on to \fBrsync\fR.
.Sp
Setting \fB\-\-rsync\-opts\fR takes precedence over setting the environment
variable \f(CW$PARALLEL_RSYNC_OPTS\fR.
.IP "\fB\-\-max\-chars\fR \fImax-chars\fR" 4
.IX Item "--max-chars max-chars"
.PD 0
.IP "\fB\-s\fR \fImax-chars\fR" 4
.IX Item "-s max-chars"
.PD
Limit length of command.
.Sp
Use at most \fImax-chars\fR characters per command line, including the
command and initial-arguments and the terminating nulls at the ends of
the argument strings.  The largest allowed value is system-dependent,
and is calculated as the argument length limit for exec, less the size
of your environment.  The default value is the maximum.
.Sp
\&\fImax-chars\fR can be postfixed with K, M, G, T, P, k, m, g, t, or p
(see \s-1UNIT PREFIX\s0).
.Sp
Implies \fB\-X\fR unless \fB\-m\fR or \fB\-\-xargs\fR is set.
.Sp
See also: \fB\-X\fR \fB\-m\fR \fB\-\-xargs\fR \fB\-\-max\-line\-length\-allowed\fR
\&\fB\-\-show\-limits\fR
.IP "\fB\-\-show\-limits\fR" 4
.IX Item "--show-limits"
Display limits given by the operating system.
.Sp
Display the limits on the command-line length which are imposed by the
operating system and the \fB\-s\fR option.  Pipe the input from /dev/null
(and perhaps specify \-\-no\-run\-if\-empty) if you don't want \s-1GNU\s0 \fBparallel\fR
to do anything.
.Sp
See also: \fB\-\-max\-chars\fR \fB\-\-max\-line\-length\-allowed\fR \fB\-\-version\fR
.IP "\fB\-\-semaphore\fR" 4
.IX Item "--semaphore"
Work as a counting semaphore.
.Sp
\&\fB\-\-semaphore\fR will cause \s-1GNU\s0 \fBparallel\fR to start \fIcommand\fR in the
background. When the number of jobs given by \fB\-\-jobs\fR is reached, \s-1GNU\s0
\&\fBparallel\fR will wait for one of these to complete before starting
another command.
.Sp
\&\fB\-\-semaphore\fR implies \fB\-\-bg\fR unless \fB\-\-fg\fR is specified.
.Sp
The command \fBsem\fR is an alias for \fBparallel \-\-semaphore\fR.
.Sp
See also: \fBman sem\fR \fB\-\-bg\fR \fB\-\-fg\fR \fB\-\-semaphore\-name\fR
\&\fB\-\-semaphore\-timeout\fR \fB\-\-wait\fR
.IP "\fB\-\-semaphore\-name\fR \fIname\fR" 4
.IX Item "--semaphore-name name"
.PD 0
.IP "\fB\-\-id\fR \fIname\fR" 4
.IX Item "--id name"
.PD
Use \fBname\fR as the name of the semaphore.
.Sp
The default is the name of the controlling tty (output from \fBtty\fR).
.Sp
The default normally works as expected when used interactively, but
when used in a script \fIname\fR should be set. \fI$$\fR or \fImy_task_name\fR
are often a good value.
.Sp
The semaphore is stored in ~/.parallel/semaphores/
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also: \fBman sem\fR \fB\-\-semaphore\fR
.IP "\fB\-\-semaphore\-timeout\fR \fIsecs\fR" 4
.IX Item "--semaphore-timeout secs"
.PD 0
.IP "\fB\-\-st\fR \fIsecs\fR" 4
.IX Item "--st secs"
.PD
If \fIsecs\fR > 0: If the semaphore is not released within \fIsecs\fR
seconds, take it anyway.
.Sp
If \fIsecs\fR < 0: If the semaphore is not released within \fIsecs\fR
seconds, exit.
.Sp
\&\fIsecs\fR is in seconds, but can be postfixed with s, m, h, or d (see
the section \s-1TIME POSTFIXES\s0).
.Sp
Implies \fB\-\-semaphore\fR.
.Sp
See also: \fBman sem\fR
.IP "\fB\-\-seqreplace\fR \fIreplace-str\fR" 4
.IX Item "--seqreplace replace-str"
Use the replacement string \fIreplace-str\fR instead of \fB{#}\fR for
job sequence number.
.Sp
See also: \fB{#}\fR
.IP "\fB\-\-session\fR" 4
.IX Item "--session"
Record names in current environment in \fB\f(CB$PARALLEL_IGNORED_NAMES\fB\fR and
exit.
.Sp
Only used with \fBenv_parallel\fR. Aliases, functions, and variables with
names in \fB\f(CB$PARALLEL_IGNORED_NAMES\fB\fR will not be copied.  So you should
set variables/function you want copied \fIafter\fR running \fB\-\-session\fR.
.Sp
It is similar to \fB\-\-record\-env\fR, but only for this session.
.Sp
Only supported in \fBAsh, Bash, Dash, Ksh, Sh, and Zsh\fR.
.Sp
See also: \fB\-\-env\fR \fB\-\-record\-env\fR \fBenv_parallel\fR
.IP "\fB\-\-shard\fR \fIshardexpr\fR" 4
.IX Item "--shard shardexpr"
Use \fIshardexpr\fR as shard key and shard input to the jobs.
.Sp
\&\fIshardexpr\fR is [column number|column name] [perlexpression] e.g.:
.Sp
.Vb 4
\&  3
\&  Address
\&  3 $_%=100
\&  Address s/\ed//g
.Ve
.Sp
Each input line is split using \fB\-\-colsep\fR. The string of the column
is put into \f(CW$_\fR, the perl expression is executed, the resulting string
is hashed so that all lines of a given value is given to the same job
slot.
.Sp
This is similar to sharding in databases.
.Sp
The performance is in the order of 100K rows per second. Faster if the
\&\fIshardcol\fR is small (<10), slower if it is big (>100).
.Sp
\&\fB\-\-shard\fR requires \fB\-\-pipe\fR and a fixed numeric value for \fB\-\-jobs\fR.
.Sp
See the section: \s-1SPREADING BLOCKS OF DATA.\s0
.Sp
See also: \fB\-\-bin\fR \fB\-\-group\-by\fR \fB\-\-round\-robin\fR
.IP "\fB\-\-shebang\fR" 4
.IX Item "--shebang"
.PD 0
.IP "\fB\-\-hashbang\fR" 4
.IX Item "--hashbang"
.PD
\&\s-1GNU\s0 \fBparallel\fR can be called as a shebang (#!) command as the first
line of a script. The content of the file will be treated as
inputsource.
.Sp
Like this:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang \-r wget
\&
\&  https://ftpmirror.gnu.org/parallel/parallel\-20120822.tar.bz2
\&  https://ftpmirror.gnu.org/parallel/parallel\-20130822.tar.bz2
\&  https://ftpmirror.gnu.org/parallel/parallel\-20140822.tar.bz2
.Ve
.Sp
\&\fB\-\-shebang\fR must be set as the first option.
.Sp
On FreeBSD \fBenv\fR is needed:
.Sp
.Vb 1
\&  #!/usr/bin/env \-S parallel \-\-shebang \-r wget
\&
\&  https://ftpmirror.gnu.org/parallel/parallel\-20120822.tar.bz2
\&  https://ftpmirror.gnu.org/parallel/parallel\-20130822.tar.bz2
\&  https://ftpmirror.gnu.org/parallel/parallel\-20140822.tar.bz2
.Ve
.Sp
There are many limitations of shebang (#!) depending on your operating
system. See details on https://www.in\-ulm.de/~mascheck/various/shebang/
.Sp
See also: \fB\-\-shebang\-wrap\fR
.IP "\fB\-\-shebang\-wrap\fR" 4
.IX Item "--shebang-wrap"
\&\s-1GNU\s0 \fBparallel\fR can parallelize scripts by wrapping the shebang
line. If the program can be run like this:
.Sp
.Vb 1
\&  cat arguments | parallel the_program
.Ve
.Sp
then the script can be changed to:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /original/parser \-\-options
.Ve
.Sp
E.g.
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap /usr/bin/python
.Ve
.Sp
If the program can be run like this:
.Sp
.Vb 1
\&  cat data | parallel \-\-pipe the_program
.Ve
.Sp
then the script can be changed to:
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap \-\-pipe /orig/parser \-\-opts
.Ve
.Sp
E.g.
.Sp
.Vb 1
\&  #!/usr/bin/parallel \-\-shebang\-wrap \-\-pipe /usr/bin/perl \-w
.Ve
.Sp
\&\fB\-\-shebang\-wrap\fR must be set as the first option.
.Sp
See also: \fB\-\-shebang\fR
.IP "\fB\-\-shell\-completion\fR \fIshell\fR" 4
.IX Item "--shell-completion shell"
Generate shell completion code for interactive shells.
.Sp
Supported shells: bash zsh.
.Sp
Use \fIauto\fR as \fIshell\fR to automatically detect running shell.
.Sp
Activate the completion code with:
.Sp
.Vb 2
\&  zsh% eval "$(parallel \-\-shell\-completion auto)"
\&  bash$ eval "$(parallel \-\-shell\-completion auto)"
.Ve
.Sp
Or put this `/usr/share/zsh/site\-functions/_parallel`, then `compinit`
to generate `~/.zcompdump`:
.Sp
.Vb 1
\&  #compdef parallel
\&  
\&  (( $+functions[_comp_parallel] )) ||
\&    eval "$(parallel \-\-shell\-completion auto)" &&
\&    _comp_parallel
.Ve
.IP "\fB\-\-shell\-quote\fR" 4
.IX Item "--shell-quote"
Does not run the command but quotes it. Useful for making quoted
composed commands for \s-1GNU\s0 \fBparallel\fR.
.Sp
Multiple \fB\-\-shell\-quote\fR with quote the string multiple times, so
\&\fBparallel \-\-shell\-quote | parallel \-\-shell\-quote\fR can be written as
\&\fBparallel \-\-shell\-quote \-\-shell\-quote\fR.
.Sp
See also: \fB\-\-quote\fR
.IP "\fB\-\-shuf\fR" 4
.IX Item "--shuf"
Shuffle jobs.
.Sp
When having multiple input sources it is hard to randomize
jobs. \fB\-\-shuf\fR will generate all jobs, and shuffle them before
running them. This is useful to get a quick preview of the results
before running the full batch.
.Sp
Combined with \fB\-\-halt soon,done=1%\fR you can run a random 1% sample of
all jobs:
.Sp
.Vb 1
\&  parallel \-\-shuf \-\-halt soon,done=1% echo ::: {1..100} ::: {1..100}
.Ve
.Sp
See also: \fB\-\-halt\fR
.IP "\fB\-\-skip\-first\-line\fR" 4
.IX Item "--skip-first-line"
Do not use the first line of input (used by \s-1GNU\s0 \fBparallel\fR itself
when called with \fB\-\-shebang\fR).
.IP "\fB\-\-sql\fR \fI\s-1DBURL\s0\fR (obsolete)" 4
.IX Item "--sql DBURL (obsolete)"
Use \fB\-\-sql\-master\fR instead.
.IP "\fB\-\-sql\-master\fR \fI\s-1DBURL\s0\fR" 4
.IX Item "--sql-master DBURL"
Submit jobs via \s-1SQL\s0 server. \fI\s-1DBURL\s0\fR must point to a table, which will
contain the same information as \fB\-\-joblog\fR, the values from the input
sources (stored in columns V1 .. Vn), and the output (stored in
columns Stdout and Stderr).
.Sp
If \fI\s-1DBURL\s0\fR is prepended with '+' \s-1GNU\s0 \fBparallel\fR assumes the table is
already made with the correct columns and appends the jobs to it.
.Sp
If \fI\s-1DBURL\s0\fR is not prepended with '+' the table will be dropped and
created with the correct amount of V\-columns unless
.Sp
\&\fB\-\-sqlmaster\fR does not run any jobs, but it creates the values for
the jobs to be run. One or more \fB\-\-sqlworker\fR must be run to actually
execute the jobs.
.Sp
If \fB\-\-wait\fR is set, \s-1GNU\s0 \fBparallel\fR will wait for the jobs to
complete.
.Sp
The format of a \s-1DBURL\s0 is:
.Sp
.Vb 1
\&  [sql:]vendor://[[user][:pwd]@][host][:port]/[db]/table
.Ve
.Sp
E.g.
.Sp
.Vb 7
\&  sql:mysql://hr:hr@localhost:3306/hrdb/jobs
\&  mysql://scott:tiger@my.example.com/pardb/paralleljobs
\&  sql:oracle://scott:tiger@ora.example.com/xe/parjob
\&  postgresql://scott:tiger@pg.example.com/pgdb/parjob
\&  pg:///parjob
\&  sqlite3:///%2Ftmp%2Fpardb.sqlite/parjob
\&  csv:///%2Ftmp%2Fpardb/parjob
.Ve
.Sp
Notice how / in the path of sqlite and \s-1CVS\s0 must be encoded as
\&\f(CW%2F\fR. Except the last / in \s-1CSV\s0 which must be a /.
.Sp
It can also be an alias from ~/.sql/aliases:
.Sp
.Vb 1
\&  :myalias mysql:///mydb/paralleljobs
.Ve
.Sp
See also: \fB\-\-sql\-and\-worker\fR \fB\-\-sql\-worker\fR \fB\-\-joblog\fR
.IP "\fB\-\-sql\-and\-worker\fR \fI\s-1DBURL\s0\fR" 4
.IX Item "--sql-and-worker DBURL"
Shorthand for: \fB\-\-sql\-master\fR \fI\s-1DBURL\s0\fR \fB\-\-sql\-worker\fR \fI\s-1DBURL\s0\fR.
.Sp
See also: \fB\-\-sql\-master\fR \fB\-\-sql\-worker\fR
.IP "\fB\-\-sql\-worker\fR \fI\s-1DBURL\s0\fR" 4
.IX Item "--sql-worker DBURL"
Execute jobs via \s-1SQL\s0 server. Read the input sources variables from the
table pointed to by \fI\s-1DBURL\s0\fR. The \fIcommand\fR on the command line
should be the same as given by \fB\-\-sqlmaster\fR.
.Sp
If you have more than one \fB\-\-sqlworker\fR jobs may be run more than
once.
.Sp
If \fB\-\-sqlworker\fR runs on the local machine, the hostname in the \s-1SQL\s0
table will not be ':' but instead the hostname of the machine.
.Sp
See also: \fB\-\-sql\-master\fR \fB\-\-sql\-and\-worker\fR
.IP "\fB\-\-ssh\fR \fIsshcommand\fR" 4
.IX Item "--ssh sshcommand"
\&\s-1GNU\s0 \fBparallel\fR defaults to using \fBssh\fR for remote access. This can
be overridden with \fB\-\-ssh\fR. It can also be set on a per server
basis with \fB\-\-sshlogin\fR.
.Sp
See also: \fB\-\-sshlogin\fR
.IP "\fB\-\-ssh\-delay\fR \fIduration\fR" 4
.IX Item "--ssh-delay duration"
Delay starting next ssh by \fIduration\fR.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will not start another ssh for the next \fIduration\fR.
.Sp
\&\fIduration\fR is in seconds, but can be postfixed with s, m, h, or d.
.Sp
See also: \s-1TIME POSTFIXES\s0 \fB\-\-sshlogin\fR \fB\-\-delay\fR
.IP "\fB\-\-sshlogin\fR \fI[@hostgroups/][ncpus/]sshlogin[,[@hostgroups/][ncpus/]sshlogin[,...]]\fR" 4
.IX Item "--sshlogin [@hostgroups/][ncpus/]sshlogin[,[@hostgroups/][ncpus/]sshlogin[,...]]"
.PD 0
.IP "\fB\-\-sshlogin\fR \fI\f(CI@hostgroup\fI\fR" 4
.IX Item "--sshlogin @hostgroup"
.IP "\fB\-S\fR \fI[@hostgroups/][ncpus/]sshlogin[,[@hostgroups/][ncpus/]sshlogin[,...]]\fR" 4
.IX Item "-S [@hostgroups/][ncpus/]sshlogin[,[@hostgroups/][ncpus/]sshlogin[,...]]"
.IP "\fB\-S\fR \fI\f(CI@hostgroup\fI\fR" 4
.IX Item "-S @hostgroup"
.PD
Distribute jobs to remote computers.
.Sp
The jobs will be run on a list of remote computers.
.Sp
If \fIhostgroups\fR is given, the \fIsshlogin\fR will be added to that
hostgroup. Multiple hostgroups are separated by '+'. The \fIsshlogin\fR
will always be added to a hostgroup named the same as \fIsshlogin\fR.
.Sp
If only the \fI\f(CI@hostgroup\fI\fR is given, only the sshlogins in that
hostgroup will be used. Multiple \fI\f(CI@hostgroup\fI\fR can be given.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will determine the number of CPUs on the remote
computers and run the number of jobs as specified by \fB\-j\fR.  If the
number \fIncpus\fR is given \s-1GNU\s0 \fBparallel\fR will use this number for
number of CPUs on the host. Normally \fIncpus\fR will not be
needed.
.Sp
An \fIsshlogin\fR is of the form:
.Sp
.Vb 1
\&  [sshcommand [options]] [username[:password]@]hostname
.Ve
.Sp
If \fIpassword\fR is given, \fBsshpass\fR will be used. Otherwise the
sshlogin must not require a password (\fBssh-agent\fR and \fBssh-copy-id\fR
may help with that).
.Sp
If the hostname is an IPv6 address, the port can be given separated
with p or #. If the address is enclosed in [] you can also use :.
E.g. ::1p2222 ::1#2222 [::1]:2222
.Sp
The sshlogin ':' is special, it means 'no ssh' and will therefore run
on the local computer.
.Sp
The sshlogin '..' is special, it read sshlogins from ~/.parallel/sshloginfile or
\&\f(CW$XDG_CONFIG_HOME\fR/parallel/sshloginfile
.Sp
The sshlogin '\-' is special, too, it read sshlogins from stdin
(standard input).
.Sp
To specify more sshlogins separate the sshlogins by comma, newline (in
the same string), or repeat the options multiple times.
.Sp
\&\s-1GNU\s0 \fBparallel\fR splits on , (comma) so if your sshlogin contains ,
(comma) you need to replace it with \e, or ,,
.Sp
For examples: see \fB\-\-sshloginfile\fR.
.Sp
The remote host must have \s-1GNU\s0 \fBparallel\fR installed.
.Sp
\&\fB\-\-sshlogin\fR is known to cause problems with \fB\-m\fR and \fB\-X\fR.
.Sp
See also: \fB\-\-basefile\fR \fB\-\-transferfile\fR \fB\-\-return\fR \fB\-\-cleanup\fR
\&\fB\-\-trc\fR \fB\-\-sshloginfile\fR \fB\-\-workdir\fR \fB\-\-filter\-hosts\fR
\&\fB\-\-ssh\fR
.IP "\fB\-\-sshloginfile\fR \fIfilename\fR" 4
.IX Item "--sshloginfile filename"
.PD 0
.IP "\fB\-\-slf\fR \fIfilename\fR" 4
.IX Item "--slf filename"
.PD
File with sshlogins. The file consists of sshlogins on separate
lines. Empty lines and lines starting with '#' are ignored. Example:
.Sp
.Vb 10
\&  server.example.com
\&  username@server2.example.com
\&  8/my\-8\-cpu\-server.example.com
\&  2/my_other_username@my\-dualcore.example.net
\&  # This server has SSH running on port 2222
\&  ssh \-p 2222 server.example.net
\&  4/ssh \-p 2222 quadserver.example.net
\&  # Use a different ssh program
\&  myssh \-p 2222 \-l myusername hexacpu.example.net
\&  # Use a different ssh program with default number of CPUs
\&  //usr/local/bin/myssh \-p 2222 \-l myusername hexacpu
\&  # Use a different ssh program with 6 CPUs
\&  6//usr/local/bin/myssh \-p 2222 \-l myusername hexacpu
\&  # Assume 16 CPUs on the local computer
\&  16/:
\&  # Put server1 in hostgroup1
\&  @hostgroup1/server1
\&  # Put myusername@server2 in hostgroup1+hostgroup2
\&  @hostgroup1+hostgroup2/myusername@server2
\&  # Force 4 CPUs and put \*(Aqssh \-p 2222 server3\*(Aq in hostgroup1
\&  @hostgroup1/4/ssh \-p 2222 server3
.Ve
.Sp
When using a different ssh program the last argument must be the hostname.
.Sp
Multiple \fB\-\-sshloginfile\fR are allowed.
.Sp
\&\s-1GNU\s0 \fBparallel\fR will first look for the file in current dir; if that
fails it look for the file in ~/.parallel.
.Sp
The sshloginfile '..' is special, it read sshlogins from
~/.parallel/sshloginfile
.Sp
The sshloginfile '.' is special, it read sshlogins from
/etc/parallel/sshloginfile
.Sp
The sshloginfile '\-' is special, too, it read sshlogins from stdin
(standard input).
.Sp
If the sshloginfile is changed it will be re-read when a job finishes
though at most once per second. This makes it possible to add and
remove hosts while running.
.Sp
This can be used to have a daemon that updates the sshloginfile to
only contain servers that are up:
.Sp
.Vb 10
\&    cp original.slf tmp2.slf
\&    while [ 1 ] ; do
\&      nice parallel \-\-nonall \-j0 \-k \-\-slf original.slf \e
\&        \-\-tag echo | perl \*(Aqs/\et$//\*(Aq > tmp.slf
\&      if diff tmp.slf tmp2.slf; then
\&        mv tmp.slf tmp2.slf
\&      fi
\&      sleep 10
\&    done &
\&    parallel \-\-slf tmp2.slf ...
.Ve
.Sp
See also: \fB\-\-filter\-hosts\fR
.IP "\fB\-\-slotreplace\fR \fIreplace-str\fR" 4
.IX Item "--slotreplace replace-str"
Use the replacement string \fIreplace-str\fR instead of \fB{%}\fR for
job slot number.
.Sp
See also: \fB{%}\fR
.IP "\fB\-\-silent\fR" 4
.IX Item "--silent"
Silent.
.Sp
The job to be run will not be printed. This is the default.  Can be
reversed with \fB\-v\fR.
.Sp
See also: \fB\-v\fR
.IP "\fB\-\-template\fR \fIfile\fR=\fIrepl\fR" 4
.IX Item "--template file=repl"
.PD 0
.IP "\fB\-\-tmpl\fR \fIfile\fR=\fIrepl\fR" 4
.IX Item "--tmpl file=repl"
.PD
Replace replacement strings in \fIfile\fR and save it in \fIrepl\fR.
.Sp
All replacement strings in the contents of \fIfile\fR will be
replaced. All replacement strings in the name \fIrepl\fR will be
replaced.
.Sp
With \fB\-\-cleanup\fR the new file will be removed when the job is done.
.Sp
If \fImy.tmpl\fR contains this:
.Sp
.Vb 7
\&  Xval: {x}
\&  Yval: {y}
\&  FixedValue: 9
\&  # x with 2 decimals
\&  DecimalX: {=x $_=sprintf("%.2f",$_) =}
\&  TenX: {=x $_=$_*10 =}
\&  RandomVal: {=1 $_=rand() =}
.Ve
.Sp
it can be used like this:
.Sp
.Vb 4
\&  myprog() { echo Using "$@"; cat "$@"; }
\&  export \-f myprog
\&  parallel \-\-cleanup \-\-header : \-\-tmpl my.tmpl={#}.t myprog {#}.t \e
\&    ::: x 1.234 2.345 3.45678 ::: y 1 2 3
.Ve
.Sp
See also: \fB{}\fR \fB\-\-cleanup\fR
.IP "\fB\-\-tty\fR" 4
.IX Item "--tty"
Open terminal tty.
.Sp
If \s-1GNU\s0 \fBparallel\fR is used for starting a program that accesses the
tty (such as an interactive program) then this option may be
needed. It will default to starting only one job at a time
(i.e. \fB\-j1\fR), not buffer the output (i.e. \fB\-u\fR), and it will open a
tty for the job.
.Sp
You can of course override \fB\-j1\fR and \fB\-u\fR.
.Sp
Using \fB\-\-tty\fR unfortunately means that \s-1GNU\s0 \fBparallel\fR cannot kill
the jobs (with \fB\-\-timeout\fR, \fB\-\-memfree\fR, or \fB\-\-halt\fR). This is due
to \s-1GNU\s0 \fBparallel\fR giving each child its own process group, which is
then killed. Process groups are dependant on the tty.
.Sp
See also: \fB\-\-ungroup\fR \fB\-\-open\-tty\fR
.IP "\fB\-\-tag\fR" 4
.IX Item "--tag"
Tag lines with arguments.
.Sp
Each output line will be prepended with the arguments and \s-1TAB\s0
(\et). When combined with \fB\-\-onall\fR or \fB\-\-nonall\fR the lines will be
prepended with the sshlogin instead.
.Sp
\&\fB\-\-tag\fR is ignored when using \fB\-u\fR.
.Sp
See also: \fB\-\-tagstring\fR \fB\-\-ctag\fR
.IP "\fB\-\-tagstring\fR \fIstr\fR" 4
.IX Item "--tagstring str"
Tag lines with a string.
.Sp
Each output line will be prepended with \fIstr\fR and \s-1TAB\s0 (\et). \fIstr\fR
can contain replacement strings such as \fB{}\fR.
.Sp
\&\fB\-\-tagstring\fR is ignored when using \fB\-u\fR, \fB\-\-onall\fR, and \fB\-\-nonall\fR.
.Sp
See also: \fB\-\-tag\fR \fB\-\-ctagstring\fR
.IP "\fB\-\-tee\fR" 4
.IX Item "--tee"
Pipe all data to all jobs.
.Sp
Used with \fB\-\-pipe\fR/\fB\-\-pipe\-part\fR and \fB:::\fR.
.Sp
.Vb 1
\&  seq 1000 | parallel \-\-pipe \-\-tee \-v wc {} ::: \-w \-l \-c
.Ve
.Sp
How many numbers in 1..1000 contain 0..9, and how many bytes do they
fill:
.Sp
.Vb 2
\&  seq 1000 | parallel \-\-pipe \-\-tee \-\-tag \e
\&    \*(Aqgrep {1} | wc {2}\*(Aq ::: {0..9} ::: \-l \-c
.Ve
.Sp
How many words contain a..z and how many bytes do they fill?
.Sp
.Vb 2
\&  parallel \-a /usr/share/dict/words \-\-pipe\-part \-\-tee \-\-tag \e
\&    \*(Aqgrep {1} | wc {2}\*(Aq ::: {a..z} ::: \-l \-c
.Ve
.Sp
See also: \fB:::\fR \fB\-\-pipe\fR \fB\-\-pipe\-part\fR
.IP "\fB\-\-term\-seq\fR \fIsequence\fR" 4
.IX Item "--term-seq sequence"
Termination sequence.
.Sp
When a job is killed due to \fB\-\-timeout\fR, \fB\-\-memfree\fR, \fB\-\-halt\fR, or
abnormal termination of \s-1GNU\s0 \fBparallel\fR, \fIsequence\fR determines how
the job is killed. The default is:
.Sp
.Vb 1
\&    TERM,200,TERM,100,TERM,50,KILL,25
.Ve
.Sp
which sends a \s-1TERM\s0 signal, waits 200 ms, sends another \s-1TERM\s0 signal,
waits 100 ms, sends another \s-1TERM\s0 signal, waits 50 ms, sends a \s-1KILL\s0
signal, waits 25 ms, and exits. \s-1GNU\s0 \fBparallel\fR detects if a process
dies before the waiting time is up.
.Sp
See also: \fB\-\-halt\fR \fB\-\-timeout\fR \fB\-\-memfree\fR
.IP "\fB\-\-total\-jobs\fR \fIjobs\fR" 4
.IX Item "--total-jobs jobs"
.PD 0
.IP "\fB\-\-total\fR \fIjobs\fR" 4
.IX Item "--total jobs"
.PD
Provide the total number of jobs for computing \s-1ETA\s0 which is also used
for \fB\-\-bar\fR.
.Sp
Without \fB\-\-total\-jobs\fR \s-1GNU\s0 Parallel will read all jobs before
starting a job. \fB\-\-total\-jobs\fR is useful if the input is generated
slowly.
.Sp
See also: \fB\-\-bar\fR \fB\-\-eta\fR
.IP "\fB\-\-tmpdir\fR \fIdirname\fR" 4
.IX Item "--tmpdir dirname"
Directory for temporary files.
.Sp
\&\s-1GNU\s0 \fBparallel\fR normally buffers output into temporary files in
/tmp. By setting \fB\-\-tmpdir\fR you can use a different dir for the
files. Setting \fB\-\-tmpdir\fR is equivalent to setting \f(CW$TMPDIR\fR.
.Sp
See also: \fB\-\-compress\fR \fB\f(CB$TMPDIR\fB\fR \fB\f(CB$PARALLEL_REMOTE_TMPDIR\fB\fR
.IP "\fB\-\-tmux\fR (Long beta testing)" 4
.IX Item "--tmux (Long beta testing)"
Use \fBtmux\fR for output. Start a \fBtmux\fR session and run each job in a
window in that session. No other output will be produced.
.Sp
See also: \fB\-\-tmuxpane\fR
.IP "\fB\-\-tmuxpane\fR (Long beta testing)" 4
.IX Item "--tmuxpane (Long beta testing)"
Use \fBtmux\fR for output but put output into panes in the first window.
Useful if you want to monitor the progress of less than 100 concurrent
jobs.
.Sp
See also: \fB\-\-tmux\fR
.IP "\fB\-\-timeout\fR \fIduration\fR" 4
.IX Item "--timeout duration"
Time out for command. If the command runs for longer than \fIduration\fR
seconds it will get killed as per \fB\-\-term\-seq\fR.
.Sp
If \fIduration\fR is followed by a % then the timeout will dynamically be
computed as a percentage of the median average runtime of successful
jobs. Only values > 100% will make sense.
.Sp
\&\fIduration\fR is in seconds, but can be postfixed with s, m, h, or d.
.Sp
See also: \s-1TIME POSTFIXES\s0 \fB\-\-term\-seq\fR \fB\-\-retries\fR
.IP "\fB\-\-verbose\fR" 4
.IX Item "--verbose"
.PD 0
.IP "\fB\-t\fR" 4
.IX Item "-t"
.PD
Print the job to be run on stderr (standard error).
.Sp
See also: \fB\-v\fR \fB\-\-interactive\fR
.IP "\fB\-\-transfer\fR" 4
.IX Item "--transfer"
Transfer files to remote computers.
.Sp
Shorthand for: \fB\-\-transferfile {}\fR.
.Sp
See also: \fB\-\-transferfile\fR.
.IP "\fB\-\-transferfile\fR \fIfilename\fR" 4
.IX Item "--transferfile filename"
.PD 0
.IP "\fB\-\-tf\fR \fIfilename\fR" 4
.IX Item "--tf filename"
.PD
Transfer \fIfilename\fR to remote computers.
.Sp
\&\fB\-\-transferfile\fR is used with \fB\-\-sshlogin\fR to transfer files to the
remote computers. The files will be transferred using \fBrsync\fR and
will be put relative to the work dir.
.Sp
The \fIfilename\fR will normally contain a replacement string.
.Sp
If the path contains /./ the remaining path will be relative to the
work dir (for details: see \fBrsync\fR). If the work dir is
\&\fB/home/user\fR, the transferring will be as follows:
.Sp
.Vb 4
\&  /tmp/foo/bar   => /tmp/foo/bar
\&  tmp/foo/bar    => /home/user/tmp/foo/bar
\&  /tmp/./foo/bar => /home/user/foo/bar
\&  tmp/./foo/bar  => /home/user/foo/bar
.Ve
.Sp
\&\fIExamples\fR
.Sp
This will transfer the file \fIfoo/bar.txt\fR to the computer
\&\fIserver.example.com\fR to the file \fI\f(CI$HOME\fI/foo/bar.txt\fR before running
\&\fBwc foo/bar.txt\fR on \fIserver.example.com\fR:
.Sp
.Vb 2
\&  echo foo/bar.txt | parallel \-\-transferfile {} \e
\&    \-\-sshlogin server.example.com wc
.Ve
.Sp
This will transfer the file \fI/tmp/foo/bar.txt\fR to the computer
\&\fIserver.example.com\fR to the file \fI/tmp/foo/bar.txt\fR before running
\&\fBwc /tmp/foo/bar.txt\fR on \fIserver.example.com\fR:
.Sp
.Vb 2
\&  echo /tmp/foo/bar.txt | parallel \-\-transferfile {} \e
\&    \-\-sshlogin server.example.com wc
.Ve
.Sp
This will transfer the file \fI/tmp/foo/bar.txt\fR to the computer
\&\fIserver.example.com\fR to the file \fIfoo/bar.txt\fR before running
\&\fBwc ./foo/bar.txt\fR on \fIserver.example.com\fR:
.Sp
.Vb 2
\&  echo /tmp/./foo/bar.txt | parallel \-\-transferfile {} \e
\&    \-\-sshlogin server.example.com wc {= s:.*/\e./:./: =}
.Ve
.Sp
\&\fB\-\-transferfile\fR is often used with \fB\-\-return\fR and \fB\-\-cleanup\fR. A
shorthand for \fB\-\-transferfile {}\fR is \fB\-\-transfer\fR.
.Sp
\&\fB\-\-transferfile\fR is ignored when used with \fB\-\-sshlogin :\fR or when
not used with \fB\-\-sshlogin\fR.
.Sp
See also: \fB\-\-workdir\fR \fB\-\-sshlogin\fR \fB\-\-basefile\fR \fB\-\-return\fR
\&\fB\-\-cleanup\fR
.IP "\fB\-\-trc\fR \fIfilename\fR" 4
.IX Item "--trc filename"
Transfer, Return, Cleanup. Shorthand for: \fB\-\-transfer\fR \fB\-\-return\fR
\&\fIfilename\fR \fB\-\-cleanup\fR
.Sp
See also: \fB\-\-transfer\fR \fB\-\-return\fR \fB\-\-cleanup\fR
.IP "\fB\-\-trim\fR <n|l|r|lr|rl>" 4
.IX Item "--trim <n|l|r|lr|rl>"
Trim white space in input.
.RS 4
.IP "n" 4
.IX Item "n"
No trim. Input is not modified. This is the default.
.IP "l" 4
.IX Item "l"
Left trim. Remove white space from start of input. E.g. \*(L" a bc \*(R" \-> \*(L"a bc \*(R".
.IP "r" 4
.IX Item "r"
Right trim. Remove white space from end of input. E.g. \*(L" a bc \*(R" \-> \*(L" a bc\*(R".
.IP "lr" 4
.IX Item "lr"
.PD 0
.IP "rl" 4
.IX Item "rl"
.PD
Both trim. Remove white space from both start and end of input. E.g. \*(L"
a bc \*(R" \-> \*(L"a bc\*(R". This is the default if \fB\-\-colsep\fR is used.
.RE
.RS 4
.Sp
See also: \fB\-\-no\-run\-if\-empty\fR \fB{}\fR \fB\-\-colsep\fR
.RE
.IP "\fB\-\-ungroup\fR" 4
.IX Item "--ungroup"
.PD 0
.IP "\fB\-u\fR" 4
.IX Item "-u"
.PD
Ungroup output.
.Sp
Output is printed as soon as possible and bypasses \s-1GNU\s0 \fBparallel\fR
internal processing. This may cause output from different commands to
be mixed thus should only be used if you do not care about the
output. Compare these:
.Sp
.Vb 4
\&  seq 4 | parallel \-j0 \e
\&    \*(Aqsleep {};echo \-n start{};sleep {};echo {}end\*(Aq
\&  seq 4 | parallel \-u \-j0 \e
\&    \*(Aqsleep {};echo \-n start{};sleep {};echo {}end\*(Aq
.Ve
.Sp
It also disables \fB\-\-tag\fR. \s-1GNU\s0 \fBparallel\fR outputs faster with
\&\fB\-u\fR. Compare the speeds of these:
.Sp
.Vb 3
\&  parallel seq ::: 300000000 >/dev/null
\&  parallel \-u seq ::: 300000000 >/dev/null
\&  parallel \-\-line\-buffer seq ::: 300000000 >/dev/null
.Ve
.Sp
Can be reversed with \fB\-\-group\fR.
.Sp
See also: \fB\-\-line\-buffer\fR \fB\-\-group\fR
.IP "\fB\-\-extensionreplace\fR \fIreplace-str\fR" 4
.IX Item "--extensionreplace replace-str"
.PD 0
.IP "\fB\-\-er\fR \fIreplace-str\fR" 4
.IX Item "--er replace-str"
.PD
Use the replacement string \fIreplace-str\fR instead of \fB{.}\fR for input
line without extension.
.Sp
See also: \fB{.}\fR
.IP "\fB\-\-use\-sockets\-instead\-of\-threads\fR" 4
.IX Item "--use-sockets-instead-of-threads"
See also: \fB\-\-use\-cores\-instead\-of\-threads\fR
.IP "\fB\-\-use\-cores\-instead\-of\-threads\fR" 4
.IX Item "--use-cores-instead-of-threads"
.PD 0
.IP "\fB\-\-use\-cpus\-instead\-of\-cores\fR (obsolete)" 4
.IX Item "--use-cpus-instead-of-cores (obsolete)"
.PD
Determine how \s-1GNU\s0 \fBparallel\fR counts the number of CPUs.
.Sp
\&\s-1GNU\s0 \fBparallel\fR uses this number when the number of jobslots
(\fB\-\-jobs\fR) is computed relative to the number of CPUs (e.g. 100% or
+1).
.Sp
CPUs can be counted in three different ways:
.RS 4
.IP "sockets" 8
.IX Item "sockets"
The number of filled \s-1CPU\s0 sockets (i.e. the number of physical chips).
.IP "cores" 8
.IX Item "cores"
The number of physical cores (i.e. the number of physical compute
cores).
.IP "threads" 8
.IX Item "threads"
The number of hyperthreaded cores (i.e. the number of virtual
cores \- with some of them possibly being hyperthreaded)
.RE
.RS 4
.Sp
Normally the number of CPUs is computed as the number of \s-1CPU\s0
threads. With \fB\-\-use\-sockets\-instead\-of\-threads\fR or
\&\fB\-\-use\-cores\-instead\-of\-threads\fR you can force it to be computed as
the number of filled sockets or number of cores instead.
.Sp
Most users will not need these options.
.Sp
\&\fB\-\-use\-cpus\-instead\-of\-cores\fR is a (misleading) alias for
\&\fB\-\-use\-sockets\-instead\-of\-threads\fR and is kept for backwards
compatibility.
.Sp
See also: \fB\-\-number\-of\-threads\fR \fB\-\-number\-of\-cores\fR
\&\fB\-\-number\-of\-sockets\fR
.RE
.IP "\fB\-v\fR" 4
.IX Item "-v"
Verbose.
.Sp
Print the job to be run on stdout (standard output). Can be reversed
with \fB\-\-silent\fR.
.Sp
Use \fB\-v\fR \fB\-v\fR to print the wrapping ssh command when running remotely.
.Sp
See also: \fB\-t\fR
.IP "\fB\-\-version\fR" 4
.IX Item "--version"
.PD 0
.IP "\fB\-V\fR" 4
.IX Item "-V"
.PD
Print the version \s-1GNU\s0 \fBparallel\fR and exit.
.IP "\fB\-\-workdir\fR \fImydir\fR" 4
.IX Item "--workdir mydir"
.PD 0
.IP "\fB\-\-wd\fR \fImydir\fR" 4
.IX Item "--wd mydir"
.PD
Jobs will be run in the dir \fImydir\fR. The default is the current dir
for the local machine, and the login dir for remote computers.
.Sp
Files transferred using \fB\-\-transferfile\fR and \fB\-\-return\fR will be
relative to \fImydir\fR on remote computers.
.Sp
The special \fImydir\fR value \fB...\fR will create working dirs under
\&\fB~/.parallel/tmp/\fR. If \fB\-\-cleanup\fR is given these dirs will be
removed.
.Sp
The special \fImydir\fR value \fB.\fR uses the current working dir.  If the
current working dir is beneath your home dir, the value \fB.\fR is
treated as the relative path to your home dir. This means that if your
home dir is different on remote computers (e.g. if your login is
different) the relative path will still be relative to your home dir.
.Sp
To see the difference try:
.Sp
.Vb 3
\&  parallel \-S server pwd ::: ""
\&  parallel \-\-wd . \-S server pwd ::: ""
\&  parallel \-\-wd ... \-S server pwd ::: ""
.Ve
.Sp
\&\fImydir\fR can contain \s-1GNU\s0 \fBparallel\fR's replacement strings.
.IP "\fB\-\-wait\fR" 4
.IX Item "--wait"
Wait for all commands to complete.
.Sp
Used with \fB\-\-semaphore\fR or \fB\-\-sqlmaster\fR.
.Sp
See also: \fBman sem\fR
.IP "\fB\-X\fR" 4
.IX Item "-X"
Multiple arguments with context replace. Insert as many arguments as
the command line length permits. If multiple jobs are being run in
parallel: distribute the arguments evenly among the jobs. Use \fB\-j1\fR
to avoid this.
.Sp
If \fB{}\fR is not used the arguments will be appended to the line.  If
\&\fB{}\fR is used as part of a word (like \fIpic{}.jpg\fR) then the whole
word will be repeated. If \fB{}\fR is used multiple times each \fB{}\fR will
be replaced with the arguments.
.Sp
Normally \fB\-X\fR will do the right thing, whereas \fB\-m\fR can give
unexpected results if \fB{}\fR is used as part of a word.
.Sp
Support for \fB\-X\fR with \fB\-\-sshlogin\fR is limited and may fail.
.Sp
See also: \fB\-m\fR
.IP "\fB\-\-exit\fR" 4
.IX Item "--exit"
.PD 0
.IP "\fB\-x\fR" 4
.IX Item "-x"
.PD
Exit if the size (see the \fB\-s\fR option) is exceeded.
.IP "\fB\-\-xargs\fR" 4
.IX Item "--xargs"
Multiple arguments. Insert as many arguments as the command line
length permits.
.Sp
If \fB{}\fR is not used the arguments will be appended to the
line.  If \fB{}\fR is used multiple times each \fB{}\fR will be replaced
with all the arguments.
.Sp
Support for \fB\-\-xargs\fR with \fB\-\-sshlogin\fR is limited and may fail.
.Sp
See also: \fB\-X\fR
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See: \fBman parallel_examples\fR
.SH "SPREADING BLOCKS OF DATA"
.IX Header "SPREADING BLOCKS OF DATA"
\&\fB\-\-round\-robin\fR, \fB\-\-pipe\-part\fR, \fB\-\-shard\fR, \fB\-\-bin\fR and
\&\fB\-\-group\-by\fR are all specialized versions of \fB\-\-pipe\fR.
.PP
In the following \fIn\fR is the number of jobslots given by \fB\-\-jobs\fR. A
record starts with \fB\-\-recstart\fR and ends with \fB\-\-recend\fR. It is
typically a full line. A chunk is a number of full records that is
approximately the size of a block. A block can contain half records, a
chunk cannot.
.PP
\&\fB\-\-pipe\fR starts one job per chunk. It reads blocks from stdin
(standard input). It finds a record end near a block border and passes
a chunk to the program.
.PP
\&\fB\-\-pipe\-part\fR starts one job per chunk \- just like normal
\&\fB\-\-pipe\fR. It first finds record endings near all block borders in the
file and then starts the jobs. By using \fB\-\-block \-1\fR it will set the
block size to size\-of\-file/\fIn\fR. Used this way it will start \fIn\fR
jobs in total.
.PP
\&\fB\-\-round\-robin\fR starts \fIn\fR jobs in total. It reads a block and
passes a chunk to whichever job is ready to read. It does not parse
the content except for identifying where a record ends to make sure it
only passes full records.
.PP
\&\fB\-\-shard\fR starts \fIn\fR jobs in total. It parses each line to read the
string in the given column. Based on this string the line is passed to
one of the \fIn\fR jobs. All lines having this string will be given to the
same jobslot.
.PP
\&\fB\-\-bin\fR works like \fB\-\-shard\fR but the value of the column must be
numeric and is the jobslot number it will be passed to. If the value
is bigger than \fIn\fR, then \fIn\fR will be subtracted from the value until
the value is smaller than or equal to \fIn\fR.
.PP
\&\fB\-\-group\-by\fR starts one job per chunk. Record borders are not given
by \fB\-\-recend\fR/\fB\-\-recstart\fR. Instead a record is defined by a group
of lines having the same string in a given column. So the string of a
given column changes at a chunk border. With \fB\-\-pipe\fR every line is
parsed, with \fB\-\-pipe\-part\fR only a few lines are parsed to find the
chunk border.
.PP
\&\fB\-\-group\-by\fR can be combined with \fB\-\-round\-robin\fR or \fB\-\-pipe\-part\fR.
.SH "TIME POSTFIXES"
.IX Header "TIME POSTFIXES"
Arguments that give a duration are given in seconds, but can be
expressed as floats postfixed with \fBs\fR, \fBm\fR, \fBh\fR, or \fBd\fR which
would multiply the float by 1, 60, 60*60, or 60*60*24. Thus these are
equivalent: 100000 and 1d3.5h16.6m4s.
.SH "UNIT PREFIX"
.IX Header "UNIT PREFIX"
Many numerical arguments in \s-1GNU\s0 \fBparallel\fR can be postfixed with K,
M, G, T, P, k, m, g, t, or p which would multiply the number with
1024, 1048576, 1073741824, 1099511627776, 1125899906842624, 1000,
1000000, 1000000000, 1000000000000, or 1000000000000000, respectively.
.PP
You can even give it as a math expression. E.g. 1000000 can be written
as 1M\-12*2.024*2k.
.SH "QUOTING"
.IX Header "QUOTING"
\&\s-1GNU\s0 \fBparallel\fR is very liberal in quoting. You only need to quote
characters that have special meaning in shell:
.PP
.Vb 1
\&  ( ) $ \` \*(Aq " < > ; | \e
.Ve
.PP
and depending on context these needs to be quoted, too:
.PP
.Vb 1
\&  ~ & # ! ? space * {
.Ve
.PP
Therefore most people will never need more quoting than putting '\e'
in front of the special characters.
.PP
Often you can simply put \e' around every ':
.PP
.Vb 1
\&  perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq file
.Ve
.PP
can be quoted:
.PP
.Vb 1
\&  parallel perl \-ne \e\*(Aq\*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq\e\*(Aq ::: file
.Ve
.PP
However, when you want to use a shell variable you need to quote the
$\-sign. Here is an example using \f(CW$PARALLEL_SEQ\fR. This variable is set
by \s-1GNU\s0 \fBparallel\fR itself, so the evaluation of the $ must be done by
the sub shell started by \s-1GNU\s0 \fBparallel\fR:
.PP
.Vb 1
\&  seq 10 | parallel \-N2 echo seq:\e$PARALLEL_SEQ arg1:{1} arg2:{2}
.Ve
.PP
If the variable is set before \s-1GNU\s0 \fBparallel\fR starts you can do this:
.PP
.Vb 2
\&  VAR=this_is_set_before_starting
\&  echo test | parallel echo {} $VAR
.Ve
.PP
Prints: \fBtest this_is_set_before_starting\fR
.PP
It is a little more tricky if the variable contains more than one space in a row:
.PP
.Vb 2
\&  VAR="two  spaces  between  each  word"
\&  echo test | parallel echo {} \e\*(Aq"$VAR"\e\*(Aq
.Ve
.PP
Prints: \fBtest two  spaces  between  each  word\fR
.PP
If the variable should not be evaluated by the shell starting \s-1GNU\s0
\&\fBparallel\fR but be evaluated by the sub shell started by \s-1GNU\s0
\&\fBparallel\fR, then you need to quote it:
.PP
.Vb 1
\&  echo test | parallel VAR=this_is_set_after_starting \e; echo {} \e$VAR
.Ve
.PP
Prints: \fBtest this_is_set_after_starting\fR
.PP
It is a little more tricky if the variable contains space:
.PP
.Vb 2
\&  echo test |\e
\&    parallel VAR=\*(Aq"two  spaces  between  each  word"\*(Aq echo {} \e\*(Aq"$VAR"\e\*(Aq
.Ve
.PP
Prints: \fBtest two  spaces  between  each  word\fR
.PP
$$ is the shell variable containing the process id of the shell. This
will print the process id of the shell running \s-1GNU\s0 \fBparallel\fR:
.PP
.Vb 1
\&  seq 10 | parallel echo $$
.Ve
.PP
And this will print the process ids of the sub shells started by \s-1GNU\s0
\&\fBparallel\fR.
.PP
.Vb 1
\&  seq 10 | parallel echo \e$\e$
.Ve
.PP
If the special characters should not be evaluated by the sub shell
then you need to protect it against evaluation from both the shell
starting \s-1GNU\s0 \fBparallel\fR and the sub shell:
.PP
.Vb 1
\&  echo test | parallel echo {} \e\e\e$VAR
.Ve
.PP
Prints: \fBtest \f(CB$VAR\fB\fR
.PP
\&\s-1GNU\s0 \fBparallel\fR can protect against evaluation by the sub shell by
using \-q:
.PP
.Vb 1
\&  echo test | parallel \-q echo {} \e$VAR
.Ve
.PP
Prints: \fBtest \f(CB$VAR\fB\fR
.PP
This is particularly useful if you have lots of quoting. If you want
to run a perl script like this:
.PP
.Vb 1
\&  perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq file
.Ve
.PP
It needs to be quoted like one of these:
.PP
.Vb 2
\&  ls | parallel perl \-ne \*(Aq/^\e\eS+\e\es+\e\eS+\e$/\e and\e print\e \e$ARGV,\e"\e\en\e"\*(Aq
\&  ls | parallel perl \-ne \e\*(Aq\*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq\e\*(Aq
.Ve
.PP
Notice how spaces, \e's, "'s, and $'s need to be quoted. \s-1GNU\s0
\&\fBparallel\fR can do the quoting by using option \-q:
.PP
.Vb 1
\&  ls | parallel \-q  perl \-ne \*(Aq/^\eS+\es+\eS+$/ and print $ARGV,"\en"\*(Aq
.Ve
.PP
However, this means you cannot make the sub shell interpret special
characters. For example because of \fB\-q\fR this \s-1WILL NOT WORK:\s0
.PP
.Vb 2
\&  ls *.gz | parallel \-q "zcat {} >{.}"
\&  ls *.gz | parallel \-q "zcat {} | bzip2 >{.}.bz2"
.Ve
.PP
because > and | need to be interpreted by the sub shell.
.PP
If you get errors like:
.PP
.Vb 5
\&  sh: \-c: line 0: syntax error near unexpected token
\&  sh: Syntax error: Unterminated quoted string
\&  sh: \-c: line 0: unexpected EOF while looking for matching \`\*(Aq\*(Aq
\&  sh: \-c: line 1: syntax error: unexpected end of file
\&  zsh:1: no matches found:
.Ve
.PP
then you might try using \fB\-q\fR.
.PP
If you are using \fBbash\fR process substitution like \fB<(cat foo)\fR then
you may try \fB\-q\fR and prepending \fIcommand\fR with \fBbash \-c\fR:
.PP
.Vb 1
\&  ls | parallel \-q bash \-c \*(Aqwc \-c <(echo {})\*(Aq
.Ve
.PP
Or for substituting output:
.PP
.Vb 2
\&  ls | parallel \-q bash \-c \e
\&    \*(Aqtar c {} | tee >(gzip >{}.tar.gz) | bzip2 >{}.tar.bz2\*(Aq
.Ve
.PP
\&\fBConclusion\fR: If this is confusing consider avoiding having to deal
with quoting by writing a small script or a function (remember to
\&\fBexport \-f\fR the function) and have \s-1GNU\s0 \fBparallel\fR call that.
.SH "LIST RUNNING JOBS"
.IX Header "LIST RUNNING JOBS"
If you want a list of the jobs currently running you can run:
.PP
.Vb 1
\&  killall \-USR1 parallel
.Ve
.PP
\&\s-1GNU\s0 \fBparallel\fR will then print the currently running jobs on stderr
(standard error).
.SH "COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS"
.IX Header "COMPLETE RUNNING JOBS BUT DO NOT START NEW JOBS"
If you regret starting a lot of jobs you can simply break \s-1GNU\s0 \fBparallel\fR,
but if you want to make sure you do not have half-completed jobs you
should send the signal \fB\s-1SIGHUP\s0\fR to \s-1GNU\s0 \fBparallel\fR:
.PP
.Vb 1
\&  killall \-HUP parallel
.Ve
.PP
This will tell \s-1GNU\s0 \fBparallel\fR to not start any new jobs, but wait until
the currently running jobs are finished before exiting.
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.ie n .IP "$PARALLEL_HOME" 9
.el .IP "\f(CW$PARALLEL_HOME\fR" 9
.IX Item "$PARALLEL_HOME"
Dir where \s-1GNU\s0 \fBparallel\fR stores config files, semaphores, and caches
information between invocations. If set to a non-existent dir, the dir
will be created.
.Sp
Default: \f(CW$HOME\fR/.parallel.
.ie n .IP "$PARALLEL_ARGHOSTGROUPS" 9
.el .IP "\f(CW$PARALLEL_ARGHOSTGROUPS\fR" 9
.IX Item "$PARALLEL_ARGHOSTGROUPS"
When using \fB\-\-hostgroups\fR \s-1GNU\s0 \fBparallel\fR sets this to the hostgroups
of the job.
.Sp
Remember to quote the $, so it gets evaluated by the correct shell. Or
use \fB\-\-plus\fR and {agrp}.
.ie n .IP "$PARALLEL_HOSTGROUPS" 9
.el .IP "\f(CW$PARALLEL_HOSTGROUPS\fR" 9
.IX Item "$PARALLEL_HOSTGROUPS"
When using \fB\-\-hostgroups\fR \s-1GNU\s0 \fBparallel\fR sets this to the hostgroups
of the sshlogin that the job is run on.
.Sp
Remember to quote the $, so it gets evaluated by the correct shell. Or
use \fB\-\-plus\fR and {hgrp}.
.ie n .IP "$PARALLEL_JOBSLOT" 9
.el .IP "\f(CW$PARALLEL_JOBSLOT\fR" 9
.IX Item "$PARALLEL_JOBSLOT"
Set by \s-1GNU\s0 \fBparallel\fR and can be used in jobs run by \s-1GNU\s0 \fBparallel\fR.
Remember to quote the $, so it gets evaluated by the correct shell. Or
use \fB\-\-plus\fR and {slot}.
.Sp
\&\f(CW$PARALLEL_JOBSLOT\fR is the jobslot of the job. It is equal to {%} unless
the job is being retried. See {%} for details.
.ie n .IP "$PARALLEL_PID" 9
.el .IP "\f(CW$PARALLEL_PID\fR" 9
.IX Item "$PARALLEL_PID"
Set by \s-1GNU\s0 \fBparallel\fR and can be used in jobs run by \s-1GNU\s0 \fBparallel\fR.
Remember to quote the $, so it gets evaluated by the correct shell.
.Sp
This makes it possible for the jobs to communicate directly to \s-1GNU\s0
\&\fBparallel\fR.
.Sp
\&\fBExample:\fR If each of the jobs tests a solution and one of jobs finds
the solution the job can tell \s-1GNU\s0 \fBparallel\fR not to start more jobs
by: \fBkill \-HUP \f(CB$PARALLEL_PID\fB\fR. This only works on the local
computer.
.ie n .IP "$PARALLEL_RSYNC_OPTS" 9
.el .IP "\f(CW$PARALLEL_RSYNC_OPTS\fR" 9
.IX Item "$PARALLEL_RSYNC_OPTS"
Options to pass on to \fBrsync\fR. Defaults to: \-rlDzR.
.ie n .IP "$PARALLEL_SHELL" 9
.el .IP "\f(CW$PARALLEL_SHELL\fR" 9
.IX Item "$PARALLEL_SHELL"
Use this shell for the commands run by \s-1GNU\s0 \fBparallel\fR:
.RS 9
.IP "\(bu" 2
\&\f(CW$PARALLEL_SHELL\fR. If undefined use:
.IP "\(bu" 2
The shell that started \s-1GNU\s0 \fBparallel\fR. If that cannot be determined:
.IP "\(bu" 2
\&\f(CW$SHELL\fR. If undefined use:
.IP "\(bu" 2
/bin/sh
.RE
.RS 9
.RE
.ie n .IP "$PARALLEL_SSH" 9
.el .IP "\f(CW$PARALLEL_SSH\fR" 9
.IX Item "$PARALLEL_SSH"
\&\s-1GNU\s0 \fBparallel\fR defaults to using the \fBssh\fR command for remote
access. This can be overridden with \f(CW$PARALLEL_SSH\fR, which again can be
overridden with \fB\-\-ssh\fR. It can also be set on a per server basis
(see \fB\-\-sshlogin\fR).
.ie n .IP "$PARALLEL_SSHHOST" 9
.el .IP "\f(CW$PARALLEL_SSHHOST\fR" 9
.IX Item "$PARALLEL_SSHHOST"
Set by \s-1GNU\s0 \fBparallel\fR and can be used in jobs run by \s-1GNU\s0 \fBparallel\fR.
Remember to quote the $, so it gets evaluated by the correct shell. Or
use \fB\-\-plus\fR and {host}.
.Sp
\&\f(CW$PARALLEL_SSHHOST\fR is the host part of an sshlogin line. E.g.
.Sp
.Vb 1
\&  4//usr/bin/specialssh user@host
.Ve
.Sp
becomes:
.Sp
.Vb 1
\&  host
.Ve
.ie n .IP "$PARALLEL_SSHLOGIN" 9
.el .IP "\f(CW$PARALLEL_SSHLOGIN\fR" 9
.IX Item "$PARALLEL_SSHLOGIN"
Set by \s-1GNU\s0 \fBparallel\fR and can be used in jobs run by \s-1GNU\s0 \fBparallel\fR.
Remember to quote the $, so it gets evaluated by the correct shell. Or
use \fB\-\-plus\fR and {sshlogin}.
.Sp
The value is the sshlogin line with number of threads removed. E.g.
.Sp
.Vb 1
\&  4//usr/bin/specialssh user@host
.Ve
.Sp
becomes:
.Sp
.Vb 1
\&  /usr/bin/specialssh user@host
.Ve
.ie n .IP "$PARALLEL_SEQ" 9
.el .IP "\f(CW$PARALLEL_SEQ\fR" 9
.IX Item "$PARALLEL_SEQ"
Set by \s-1GNU\s0 \fBparallel\fR and can be used in jobs run by \s-1GNU\s0 \fBparallel\fR.
Remember to quote the $, so it gets evaluated by the correct shell.
.Sp
\&\f(CW$PARALLEL_SEQ\fR is the sequence number of the job running.
.Sp
\&\fBExample:\fR
.Sp
.Vb 2
\&  seq 10 | parallel \-N2 \e
\&    echo seq:\*(Aq$\*(AqPARALLEL_SEQ arg1:{1} arg2:{2}
.Ve
.Sp
{#} is a shorthand for \f(CW$PARALLEL_SEQ\fR.
.ie n .IP "$PARALLEL_TMUX" 9
.el .IP "\f(CW$PARALLEL_TMUX\fR" 9
.IX Item "$PARALLEL_TMUX"
Path to \fBtmux\fR. If unset the \fBtmux\fR in \f(CW$PATH\fR is used.
.ie n .IP "$TMPDIR" 9
.el .IP "\f(CW$TMPDIR\fR" 9
.IX Item "$TMPDIR"
Directory for temporary files.
.Sp
See also: \fB\-\-tmpdir\fR
.ie n .IP "$PARALLEL_REMOTE_TMPDIR" 9
.el .IP "\f(CW$PARALLEL_REMOTE_TMPDIR\fR" 9
.IX Item "$PARALLEL_REMOTE_TMPDIR"
Directory for temporary files on remote servers.
.Sp
See also: \fB\-\-tmpdir\fR
.ie n .IP "$PARALLEL" 9
.el .IP "\f(CW$PARALLEL\fR" 9
.IX Item "$PARALLEL"
The environment variable \f(CW$PARALLEL\fR will be used as default options for
\&\s-1GNU\s0 \fBparallel\fR. If the variable contains special shell characters
(e.g. $, *, or space) then these need to be to be escaped with \e.
.Sp
\&\fBExample:\fR
.Sp
.Vb 2
\&  cat list | parallel \-j1 \-k \-v ls
\&  cat list | parallel \-j1 \-k \-v \-S"myssh user@server" ls
.Ve
.Sp
can be written as:
.Sp
.Vb 3
\&  cat list | PARALLEL="\-kvj1" parallel ls
\&  cat list | PARALLEL=\*(Aq\-kvj1 \-S myssh\e user@server\*(Aq \e
\&    parallel echo
.Ve
.Sp
Notice the \e after 'myssh' is needed because 'myssh' and 'user@server'
must be one argument.
.Sp
See also: \fB\-\-profile\fR
.SH "DEFAULT PROFILE (CONFIG FILE)"
.IX Header "DEFAULT PROFILE (CONFIG FILE)"
The global configuration file /etc/parallel/config, followed by user
configuration file ~/.parallel/config (formerly known as .parallelrc)
will be read in turn if they exist.  Lines starting with '#' will be
ignored. The format can follow that of the environment variable
\&\f(CW$PARALLEL\fR, but it is often easier to simply put each option on its own
line.
.PP
Options on the command line take precedence, followed by the
environment variable \f(CW$PARALLEL\fR, user configuration file
~/.parallel/config, and finally the global configuration file
/etc/parallel/config.
.PP
Note that no file that is read for options, nor the environment
variable \f(CW$PARALLEL\fR, may contain retired options such as \fB\-\-tollef\fR.
.SH "PROFILE FILES"
.IX Header "PROFILE FILES"
If \fB\-\-profile\fR set, \s-1GNU\s0 \fBparallel\fR will read the profile from that
file rather than the global or user configuration files. You can have
multiple \fB\-\-profiles\fR.
.PP
Profiles are searched for in \fB~/.parallel\fR. If the name starts with
\&\fB/\fR it is seen as an absolute path. If the name starts with \fB./\fR it
is seen as a relative path from current dir.
.PP
Example: Profile for running a command on every sshlogin in
~/.ssh/sshlogins and prepend the output with the sshlogin:
.PP
.Vb 2
\&  echo \-\-tag \-S .. \-\-nonall > ~/.parallel/nonall_profile
\&  parallel \-J nonall_profile uptime
.Ve
.PP
Example: Profile for running every command with \fB\-j\-1\fR and \fBnice\fR
.PP
.Vb 2
\&  echo \-j\-1 nice > ~/.parallel/nice_profile
\&  parallel \-J nice_profile bzip2 \-9 ::: *
.Ve
.PP
Example: Profile for running a perl script before every command:
.PP
.Vb 3
\&  echo "perl \-e \*(Aq\e$a=\e$\e$; print \e$a,\e" \e",\*(Aq\e$PARALLEL_SEQ\*(Aq,\e" \e";\*(Aq;" \e
\&    > ~/.parallel/pre_perl
\&  parallel \-J pre_perl echo ::: *
.Ve
.PP
Note how the $ and " need to be quoted using \e.
.PP
Example: Profile for running distributed jobs with \fBnice\fR on the
remote computers:
.PP
.Vb 2
\&  echo \-S .. nice > ~/.parallel/dist
\&  parallel \-J dist \-\-trc {.}.bz2 bzip2 \-9 ::: *
.Ve
.SH "EXIT STATUS"
.IX Header "EXIT STATUS"
Exit status depends on \fB\-\-halt\-on\-error\fR if one of these is used:
success=X, success=Y%, fail=Y%.
.IP "0" 6
All jobs ran without error. If success=X is used: X jobs ran without
error. If success=Y% is used: Y% of the jobs ran without error.
.IP "1\-100" 6
.IX Item "1-100"
Some of the jobs failed. The exit status gives the number of failed
jobs. If Y% is used the exit status is the percentage of jobs that
failed.
.IP "101" 6
.IX Item "101"
More than 100 jobs failed.
.IP "255" 6
.IX Item "255"
Other error.
.IP "\-1 (In joblog and \s-1SQL\s0 table)" 6
.IX Item "-1 (In joblog and SQL table)"
Killed by Ctrl-C, timeout, not enough memory or similar.
.IP "\-2 (In joblog and \s-1SQL\s0 table)" 6
.IX Item "-2 (In joblog and SQL table)"
\&\fBskip()\fR was called in \fB{= =}\fR.
.IP "\-1000 (In \s-1SQL\s0 table)" 6
.IX Item "-1000 (In SQL table)"
Job is ready to run (set by \-\-sqlmaster).
.IP "\-1220 (In \s-1SQL\s0 table)" 6
.IX Item "-1220 (In SQL table)"
Job is taken by worker (set by \-\-sqlworker).
.PP
If fail=1 is used, the exit status will be the exit status of the
failing job.
.SH "DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"
.IX Header "DIFFERENCES BETWEEN GNU Parallel AND ALTERNATIVES"
See: \fBman parallel_alternatives\fR
.SH "BUGS"
.IX Header "BUGS"
.SS "Quoting of newline"
.IX Subsection "Quoting of newline"
Because of the way newline is quoted this will not work:
.PP
.Vb 1
\&  echo 1,2,3 | parallel \-vkd, "echo \*(Aqa{}b\*(Aq"
.Ve
.PP
However, these will all work:
.PP
.Vb 3
\&  echo 1,2,3 | parallel \-vkd, echo a{}b
\&  echo 1,2,3 | parallel \-vkd, "echo \*(Aqa\*(Aq{}\*(Aqb\*(Aq"
\&  echo 1,2,3 | parallel \-vkd, "echo \*(Aqa\*(Aq"{}"\*(Aqb\*(Aq"
.Ve
.SS "Speed"
.IX Subsection "Speed"
\fIStartup\fR
.IX Subsection "Startup"
.PP
\&\s-1GNU\s0 \fBparallel\fR is slow at starting up \- around 250 ms the first time
and 150 ms after that.
.PP
\fIJob startup\fR
.IX Subsection "Job startup"
.PP
Starting a job on the local machine takes around 3\-10 ms. This can be
a big overhead if the job takes very few ms to run. Often you can
group small jobs together using \fB\-X\fR which will make the overhead
less significant. Or you can run multiple \s-1GNU\s0 \fBparallel\fRs as
described in \fB\s-1EXAMPLE:\s0 Speeding up fast jobs\fR.
.PP
\fI\s-1SSH\s0\fR
.IX Subsection "SSH"
.PP
When using multiple computers \s-1GNU\s0 \fBparallel\fR opens \fBssh\fR connections
to them to figure out how many connections can be used reliably
simultaneously (Namely \s-1SSHD\s0's MaxStartups). This test is done for each
host in serial, so if your \fB\-\-sshloginfile\fR contains many hosts it may
be slow.
.PP
If your jobs are short you may see that there are fewer jobs running
on the remote systems than expected. This is due to time spent logging
in and out. \fB\-M\fR may help here.
.PP
\fIDisk access\fR
.IX Subsection "Disk access"
.PP
A single disk can normally read data faster if it reads one file at a
time instead of reading a lot of files in parallel, as this will avoid
disk seeks. However, newer disk systems with multiple drives can read
faster if reading from multiple files in parallel.
.PP
If the jobs are of the form read-all-compute-all-write-all, so
everything is read before anything is written, it may be faster to
force only one disk access at the time:
.PP
.Vb 1
\&  sem \-\-id diskio cat file | compute | sem \-\-id diskio cat > file
.Ve
.PP
If the jobs are of the form read-compute-write, so writing starts
before all reading is done, it may be faster to force only one reader
and writer at the time:
.PP
.Vb 1
\&  sem \-\-id read cat file | compute | sem \-\-id write cat > file
.Ve
.PP
If the jobs are of the form read-compute-read-compute, it may be
faster to run more jobs in parallel than the system has CPUs, as some
of the jobs will be stuck waiting for disk access.
.SS "\-\-nice limits command length"
.IX Subsection "--nice limits command length"
The current implementation of \fB\-\-nice\fR is too pessimistic in the max
allowed command length. It only uses a little more than half of what
it could. This affects \fB\-X\fR and \fB\-m\fR. If this becomes a real problem for
you, file a bug-report.
.SS "Aliases and functions do not work"
.IX Subsection "Aliases and functions do not work"
If you get:
.PP
.Vb 1
\&  Can\*(Aqt exec "command": No such file or directory
.Ve
.PP
or:
.PP
.Vb 1
\&  open3: exec of by command failed
.Ve
.PP
or:
.PP
.Vb 1
\&  /bin/bash: command: command not found
.Ve
.PP
it may be because \fIcommand\fR is not known, but it could also be
because \fIcommand\fR is an alias or a function. If it is a function you
need to \fBexport \-f\fR the function first or use \fBenv_parallel\fR. An
alias will only work if you use \fBenv_parallel\fR.
.SS "Database with MySQL fails randomly"
.IX Subsection "Database with MySQL fails randomly"
The \fB\-\-sql*\fR options may fail randomly with MySQL. This problem does
not exist with PostgreSQL.
.SH "REPORTING BUGS"
.IX Header "REPORTING BUGS"
Report bugs to <parallel@gnu.org> or
https://savannah.gnu.org/bugs/?func=additem&group=parallel
.PP
When you write your report, please keep in mind, that you must give
the reader enough information to be able to run exactly what you
run. So you need to include all data and programs that you use to
show the problem.
.PP
See a perfect bug report on
https://lists.gnu.org/archive/html/bug\-parallel/2015\-01/msg00000.html
.PP
Your bug report should always include:
.IP "\(bu" 2
The error message you get (if any). If the error message is not from
\&\s-1GNU\s0 \fBparallel\fR you need to show why you think \s-1GNU\s0 \fBparallel\fR caused
this.
.IP "\(bu" 2
The complete output of \fBparallel \-\-version\fR. If you are not running
the latest released version (see https://ftp.gnu.org/gnu/parallel/) you
should specify why you believe the problem is not fixed in that
version.
.IP "\(bu" 2
A minimal, complete, and verifiable example (See description on
https://stackoverflow.com/help/mcve).
.Sp
It should be a complete example that others can run which shows the
problem including all files needed to run the example. This should
preferably be small and simple, so try to remove as many options as
possible.
.Sp
A combination of \fByes\fR, \fBseq\fR, \fBcat\fR, \fBecho\fR, \fBwc\fR, and \fBsleep\fR
can reproduce most errors.
.Sp
If your example requires large files, see if you can make them with
something like \fBseq 100000000\fR > \fBbigfile\fR or \fByes | head \-n
1000000000\fR > \fBfile\fR. If you need multiple columns: \fBpaste <(seq
1000) <(seq 1000 1999)\fR
.Sp
If your example requires remote execution, see if you can use
\&\fBlocalhost\fR \- maybe using another login.
.Sp
If you have access to a different system (maybe a VirtualBox on your
own machine), test if your \s-1MCVE\s0 shows the problem on that system. If
it does not, read below.
.IP "\(bu" 2
The output of your example. If your problem is not easily reproduced
by others, the output might help them figure out the problem.
.IP "\(bu" 2
Whether you have watched the intro videos
(https://www.youtube.com/playlist?list=PL284C9FF2488BC6D1), walked
through the tutorial (man parallel_tutorial), and read the examples
(man parallel_examples).
.SS "Bug dependent on environment"
.IX Subsection "Bug dependent on environment"
If you suspect the error is dependent on your environment or
distribution, please see if you can reproduce the error on one of
these VirtualBox images:
https://sourceforge.net/projects/virtualboximage/files/
https://www.osboxes.org/virtualbox\-images/
.PP
Specifying the name of your distribution is not enough as you may have
installed software that is not in the VirtualBox images.
.PP
If you cannot reproduce the error on any of the VirtualBox images
above, see if you can build a VirtualBox image on which you can
reproduce the error. If not you should assume the debugging will be
done through you. That will put a lot more burden on you and it is
extra important you give any information that help. In general the
problem will be fixed faster and with much less work for you if you
can reproduce the error on a VirtualBox \- even if you have to build a
VirtualBox image.
.SS "In summary"
.IX Subsection "In summary"
Your report must include:
.IP "\(bu" 2
\&\fBparallel \-\-version\fR
.IP "\(bu" 2
output + error message
.IP "\(bu" 2
full example including all files
.IP "\(bu" 2
VirtualBox image, if you cannot reproduce it on other systems
.SH "AUTHOR"
.IX Header "AUTHOR"
When using \s-1GNU\s0 \fBparallel\fR for a publication please cite:
.PP
O. Tange (2011): \s-1GNU\s0 Parallel \- The Command-Line Power Tool, ;login:
The \s-1USENIX\s0 Magazine, February 2011:42\-47.
.PP
This helps funding further development; and it won't cost you a cent.
If you pay 10000 \s-1EUR\s0 you should feel free to use \s-1GNU\s0 Parallel without citing.
.PP
Copyright (C) 2007\-10\-18 Ole Tange, http://ole.tange.dk
.PP
Copyright (C) 2008\-2010 Ole Tange, http://ole.tange.dk
.PP
Copyright (C) 2010\-2023 Ole Tange, http://ole.tange.dk and Free
Software Foundation, Inc.
.PP
Parts of the manual concerning \fBxargs\fR compatibility is inspired by
the manual of \fBxargs\fR from \s-1GNU\s0 findutils 4.4.2.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify
it under the terms of the \s-1GNU\s0 General Public License as published by
the Free Software Foundation; either version 3 of the License, or
at your option any later version.
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0  See the
\&\s-1GNU\s0 General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
.SS "Documentation license I"
.IX Subsection "Documentation license I"
Permission is granted to copy, distribute and/or modify this
documentation under the terms of the \s-1GNU\s0 Free Documentation License,
Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, with no Front-Cover Texts, and
with no Back-Cover Texts.  A copy of the license is included in the
file \s-1LICENSES/GFDL\-1\s0.3\-or\-later.txt.
.SS "Documentation license \s-1II\s0"
.IX Subsection "Documentation license II"
You are free:
.IP "\fBto Share\fR" 9
.IX Item "to Share"
to copy, distribute and transmit the work
.IP "\fBto Remix\fR" 9
.IX Item "to Remix"
to adapt the work
.PP
Under the following conditions:
.IP "\fBAttribution\fR" 9
.IX Item "Attribution"
You must attribute the work in the manner specified by the author or
licensor (but not in any way that suggests that they endorse you or
your use of the work).
.IP "\fBShare Alike\fR" 9
.IX Item "Share Alike"
If you alter, transform, or build upon this work, you may distribute
the resulting work only under the same, similar or a compatible
license.
.PP
With the understanding that:
.IP "\fBWaiver\fR" 9
.IX Item "Waiver"
Any of the above conditions can be waived if you get permission from
the copyright holder.
.IP "\fBPublic Domain\fR" 9
.IX Item "Public Domain"
Where the work or any of its elements is in the public domain under
applicable law, that status is in no way affected by the license.
.IP "\fBOther Rights\fR" 9
.IX Item "Other Rights"
In no way are any of the following rights affected by the license:
.RS 9
.IP "\(bu" 2
Your fair dealing or fair use rights, or other applicable
copyright exceptions and limitations;
.IP "\(bu" 2
The author's moral rights;
.IP "\(bu" 2
Rights other persons may have either in the work itself or in
how the work is used, such as publicity or privacy rights.
.RE
.RS 9
.RE
.IP "\fBNotice\fR" 9
.IX Item "Notice"
For any reuse or distribution, you must make clear to others the
license terms of this work.
.PP
A copy of the full license is included in the file as
\&\s-1LICENCES/CC\-BY\-SA\-4.0\s0.txt
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
\&\s-1GNU\s0 \fBparallel\fR uses Perl, and the Perl modules Getopt::Long,
IPC::Open3, Symbol, IO::File, \s-1POSIX,\s0 and File::Temp.
.PP
For \fB\-\-csv\fR it uses the Perl module Text::CSV.
.PP
For remote usage it uses \fBrsync\fR with \fBssh\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBparallel_tutorial\fR(1), \fBenv_parallel\fR(1), \fBparset\fR(1),
\&\fBparsort\fR(1), \fBparallel_alternatives\fR(1), \fBparallel_design\fR(7),
\&\fBniceload\fR(1), \fBsql\fR(1), \fBssh\fR(1), \fBssh-agent\fR(1), \fBsshpass\fR(1),
\&\fBssh-copy-id\fR(1), \fBrsync\fR(1)
